<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>OpenCircuit</title>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;800&display=swap');

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        color-scheme: dark;
        user-select: none;
        font-family: 'JetBrains Mono', monospace;
      }

      body {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        background-color: #0f0f0f;
      }

      canvas {
        display: block;
        touch-action: none;
      }

      .hud {
        position: absolute;
        top: 15px;
        left: 15px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 12px;
        background: rgba(20, 20, 20, 0.9);
        border: 1px solid #333;
        border-radius: 6px;
        backdrop-filter: blur(8px);
        width: 140px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        z-index: 10;
        max-height: 80vh; /* Limited height to force scroll if needed */
        overflow-y: auto;
      }

      /* Custom Scrollbar for HUD */
      .hud::-webkit-scrollbar {
        width: 4px;
      }
      .hud::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
      }
      .hud::-webkit-scrollbar-thumb {
        background: #444;
        border-radius: 2px;
      }

      button {
        padding: 10px;
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 4px;
        color: #ccc;
        cursor: pointer;
        font-size: 12px;
        text-align: left;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: background 0.1s;
        flex-shrink: 0;
      }

      button:hover {
        background: #252525;
        border-color: #444;
        color: #fff;
      }

      button:active {
        background: #333;
      }

      button.danger {
        border-color: #522;
        color: #e55;
      }
      button.danger:hover {
        background: #311;
      }

      .swatch {
        width: 10px;
        height: 10px;
        border-radius: 2px;
        display: inline-block;
      }

      .controls {
        position: absolute;
        bottom: 15px;
        right: 15px;
        color: #444;
        font-size: 11px;
        text-align: right;
        pointer-events: none;
        line-height: 1.6;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>

    <div class="hud" id="hud"></div>

    <div class="controls">
      Protected: Can't place components on wires<br />
      Auto-Bridge: Gaps fill automatically<br />
      IN: Click Center to Toggle
    </div>

    <script>
      const canvas = document.getElementById('canvas')
      const ctx = canvas.getContext('2d')
      const hud = document.getElementById('hud')

      const GRID_SIZE = 25

      const TOOLS = {
        WIRE: { label: 'WIRE', color: '#888', w: 1, h: 1, ins: 0, outs: 0 },
        INPUT: { label: 'IN', color: '#3b82f6', w: 2, h: 2, ins: 0, outs: 1 },
        OUTPUT: { label: 'OUT', color: '#22c55e', w: 2, h: 2, ins: 1, outs: 0 },
        NOT: { label: 'NOT', color: '#ef4444', w: 2, h: 2, ins: 1, outs: 1 },
        AND: { label: 'AND', color: '#eab308', w: 2, h: 2, ins: 2, outs: 1 },
        NAND: { label: 'NAND', color: '#14b8a6', w: 2, h: 2, ins: 2, outs: 1 }, // Teal
        OR: { label: 'OR', color: '#a855f7', w: 2, h: 2, ins: 2, outs: 1 },
        NOR: { label: 'NOR', color: '#f97316', w: 2, h: 2, ins: 2, outs: 1 }, // Orange
        XOR: { label: 'XOR', color: '#ec4899', w: 2, h: 2, ins: 2, outs: 1 },
        XNOR: { label: 'XNOR', color: '#6366f1', w: 2, h: 2, ins: 2, outs: 1 }, // Indigo
      }

      let components = []
      let wires = new Map()
      let wireStates = new Map()

      let camera = { x: 0, y: 0 }
      let mode = 'IDLE'
      let dragStart = { x: 0, y: 0 }
      let newCompType = null
      let draggingComp = null
      let draggingWire = null
      let dragOffset = { x: 0, y: 0 }
      let initialPos = { x: 0, y: 0 }
      let mouseGrid = { x: 0, y: 0 }

      class Component {
        constructor(gx, gy, type) {
          this.gx = gx
          this.gy = gy
          this.type = type
          this.id = Math.random().toString(36).substr(2, 9)
          this.state = false
        }
      }

      function simulate() {
        let currentState = new Map()

        for (let pass = 0; pass < 3; pass++) {
          let nextState = new Map()
          let queue = []
          let visited = new Set()

          components.forEach((c) => {
            const def = TOOLS[c.type]
            let isActive = false

            if (c.type === 'INPUT') {
              isActive = c.state
            } else if (
              ['AND', 'OR', 'NOT', 'XOR', 'NAND', 'NOR', 'XNOR'].includes(
                c.type
              )
            ) {
              // Logic Inputs (Direct or Bridged)
              const in1_Direct =
                currentState.get(`${c.gx - 1},${c.gy}`) || false
              const in1_Gap = currentState.get(`${c.gx - 2},${c.gy}`) || false
              const in1 = in1_Direct || in1_Gap

              const in2_Direct =
                currentState.get(`${c.gx - 1},${c.gy + 1}`) || false
              const in2_Gap =
                currentState.get(`${c.gx - 2},${c.gy + 1}`) || false
              const in2 = in2_Direct || in2_Gap

              if (c.type === 'NOT') isActive = !in1
              if (c.type === 'AND') isActive = in1 && in2
              if (c.type === 'NAND') isActive = !(in1 && in2)
              if (c.type === 'OR') isActive = in1 || in2
              if (c.type === 'NOR') isActive = !(in1 || in2)
              if (c.type === 'XOR') isActive = !!in1 !== !!in2
              if (c.type === 'XNOR') isActive = !!in1 === !!in2
            }

            if (isActive) {
              queue.push({ x: c.gx + def.w, y: c.gy })
              queue.push({ x: c.gx + def.w + 1, y: c.gy })
            }
          })

          while (queue.length > 0) {
            const curr = queue.shift()
            const key = `${curr.x},${curr.y}`

            if (visited.has(key)) continue
            visited.add(key)

            if (wires.has(key)) {
              nextState.set(key, true)

              const neighbors = [
                { x: curr.x + 1, y: curr.y },
                { x: curr.x - 1, y: curr.y },
                { x: curr.x, y: curr.y + 1 },
                { x: curr.x, y: curr.y - 1 },
              ]

              neighbors.forEach((n) => {
                if (
                  wires.has(`${n.x},${n.y}`) &&
                  canConnect(curr.x, curr.y, n.x, n.y)
                ) {
                  queue.push(n)
                }
              })
            }
          }
          currentState = nextState
        }
        wireStates = currentState
      }

      function isInputPort(gx, gy) {
        return components.some((c) => {
          const def = TOOLS[c.type]
          return gx === c.gx && gy >= c.gy && gy < c.gy + def.ins
        })
      }

      function canConnect(x1, y1, x2, y2) {
        if (x1 === x2 && Math.abs(y1 - y2) === 1) {
          const rightX = x1 + 1
          const topY = Math.min(y1, y2)
          if (isInputPort(rightX, topY) && isInputPort(rightX, topY + 1)) {
            return false
          }
        }
        return true
      }

      function drawGrid() {
        ctx.strokeStyle = '#1a1a1a'
        ctx.lineWidth = 1
        ctx.beginPath()
        const offX = camera.x % GRID_SIZE
        const offY = camera.y % GRID_SIZE
        for (let x = offX; x < canvas.width; x += GRID_SIZE) {
          ctx.moveTo(x + 0.5, 0)
          ctx.lineTo(x + 0.5, canvas.height)
        }
        for (let y = offY; y < canvas.height; y += GRID_SIZE) {
          ctx.moveTo(0, y + 0.5)
          ctx.lineTo(canvas.width, y + 0.5)
        }
        ctx.stroke()
      }

      function drawWires() {
        ctx.lineCap = 'round'
        const now = Date.now()
        const pulse = (Math.sin(now / 150) + 1) / 2
        const activeColor = `rgba(255, 255, 120, ${0.7 + pulse * 0.3})`
        const activeWidth = 2 + pulse * 1.5

        wires.forEach((_, key) => {
          const [gx, gy] = key.split(',').map(Number)
          const px = gx * GRID_SIZE + camera.x + GRID_SIZE / 2
          const py = gy * GRID_SIZE + camera.y + GRID_SIZE / 2

          const isPowered = wireStates.get(key)

          ctx.strokeStyle = isPowered ? activeColor : '#555'
          ctx.lineWidth = isPowered ? activeWidth : 2
          ctx.shadowBlur = isPowered ? 8 : 0
          ctx.shadowColor = '#ffffaa'

          const u =
            wires.has(`${gx},${gy - 1}`) && canConnect(gx, gy, gx, gy - 1)
          const d =
            wires.has(`${gx},${gy + 1}`) && canConnect(gx, gy, gx, gy + 1)
          const l = wires.has(`${gx - 1},${gy}`)
          const r = wires.has(`${gx + 1},${gy}`)

          ctx.beginPath()
          if (u) {
            ctx.moveTo(px, py)
            ctx.lineTo(px, py - GRID_SIZE / 2)
          }
          if (d) {
            ctx.moveTo(px, py)
            ctx.lineTo(px, py + GRID_SIZE / 2)
          }
          if (l) {
            ctx.moveTo(px, py)
            ctx.lineTo(px - GRID_SIZE / 2, py)
          }
          if (r) {
            ctx.moveTo(px, py)
            ctx.lineTo(px + GRID_SIZE / 2, py)
          }
          ctx.stroke()

          const neighbors =
            (u ? 1 : 0) + (d ? 1 : 0) + (l ? 1 : 0) + (r ? 1 : 0)
          const isStraight = (u && d && !l && !r) || (l && r && !u && !d)

          if (
            neighbors === 0 ||
            neighbors > 2 ||
            (neighbors === 2 && !isStraight) ||
            neighbors === 1
          ) {
            ctx.fillStyle = isPowered ? activeColor : '#555'
            ctx.beginPath()
            ctx.arc(px, py, isPowered ? 4 : 3, 0, Math.PI * 2)
            ctx.fill()
          }
          ctx.shadowBlur = 0
        })
      }

      function drawComponent(c, isGhost = false) {
        if (c.type === 'WIRE') {
          const x = c.gx * GRID_SIZE + camera.x + GRID_SIZE / 2
          const y = c.gy * GRID_SIZE + camera.y + GRID_SIZE / 2
          ctx.fillStyle = '#fff'
          ctx.globalAlpha = isGhost ? 0.5 : 1.0
          ctx.beginPath()
          ctx.arc(x, y, 4, 0, Math.PI * 2)
          ctx.fill()
          ctx.globalAlpha = 1.0
          return
        }

        const def = TOOLS[c.type]
        const x = c.gx * GRID_SIZE + camera.x
        const y = c.gy * GRID_SIZE + camera.y
        const w = def.w * GRID_SIZE
        const h = def.h * GRID_SIZE

        if (isGhost) ctx.globalAlpha = 0.6
        if (isGhost && checkCollision(c.gx, c.gy, c.type))
          ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'
        else ctx.fillStyle = '#141414'

        ctx.fillRect(x, y, w, h)
        ctx.strokeStyle = def.color
        ctx.lineWidth = 2
        ctx.strokeRect(x, y, w, h)

        ctx.fillStyle = def.color
        ctx.font = 'bold 12px "JetBrains Mono"'
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'

        if (c.type === 'INPUT') {
          const pad = 10
          ctx.fillStyle = '#222'
          ctx.fillRect(x + pad, y + pad, w - pad * 2, h - pad * 2)
          ctx.fillStyle = c.state ? '#4f4' : '#333'
          ctx.fillRect(
            x + pad + 2,
            y + pad + 2,
            w - pad * 2 - 4,
            h - pad * 2 - 4
          )
          ctx.fillStyle = '#fff'
          ctx.fillText(c.state ? 'ON' : 'OFF', x + w / 2, y + h / 2)
        } else if (c.type === 'OUTPUT') {
          const inKeyDirect = `${c.gx - 1},${c.gy}`
          const inKeyGap = `${c.gx - 2},${c.gy}`
          const isLit = wireStates.get(inKeyDirect) || wireStates.get(inKeyGap)

          ctx.beginPath()
          ctx.arc(x + w / 2, y + h / 2, 12, 0, Math.PI * 2)
          ctx.fillStyle = '#222'
          ctx.fill()

          ctx.beginPath()
          ctx.arc(x + w / 2, y + h / 2, 8, 0, Math.PI * 2)
          if (isLit) {
            ctx.fillStyle = '#ffff00'
            ctx.shadowColor = '#ffff00'
            ctx.shadowBlur = 20
          } else {
            ctx.fillStyle = '#444'
          }
          ctx.fill()
          ctx.shadowBlur = 0
        } else {
          ctx.fillText(def.label, x + w / 2, y + h / 2)
        }

        const now = Date.now()
        const pulse = (Math.sin(now / 150) + 1) / 2
        const activeColor = `rgba(255, 255, 120, ${0.7 + pulse * 0.3})`

        const drawPort = (gx, gy, isInput) => {
          const px = (isInput ? gx : gx + def.w) * GRID_SIZE + camera.x
          const py = (gy + 0.5) * GRID_SIZE + camera.y

          const gapX = isInput ? gx - 2 : gx + def.w + 1
          const gapWireKey = `${gapX},${gy}`
          const hasGapWire = wires.has(gapWireKey)
          const isPowered = wireStates.get(gapWireKey)

          const len = hasGapWire ? 37 : 12
          const endX = px + (isInput ? -len : len)

          ctx.beginPath()
          ctx.moveTo(px, py)
          ctx.lineTo(endX, py)
          ctx.strokeStyle = hasGapWire && isPowered ? activeColor : '#fff'
          ctx.lineWidth = 2
          ctx.shadowBlur = hasGapWire && isPowered ? 5 : 0
          ctx.shadowColor = '#ffffaa'
          ctx.stroke()
          ctx.shadowBlur = 0

          ctx.beginPath()
          ctx.arc(endX, py, 2, 0, Math.PI * 2)
          ctx.fillStyle = hasGapWire && isPowered ? '#ffffaa' : '#fff'
          ctx.fill()
        }

        if (def.ins >= 1) drawPort(c.gx, c.gy, true)
        if (def.ins >= 2) drawPort(c.gx, c.gy + 1, true)
        if (def.outs >= 1) drawPort(c.gx, c.gy, false)

        if (isGhost) ctx.globalAlpha = 1.0
      }

      function checkCollision(gx, gy, type, excludeId = null) {
        const def = TOOLS[type]
        const w = def.w
        const h = def.h

        const compCollision = components.some((c) => {
          if (c.id === excludeId) return false
          const cDef = TOOLS[c.type]
          return (
            gx < c.gx + cDef.w &&
            gx + w > c.gx &&
            gy < c.gy + cDef.h &&
            gy + h > c.gy
          )
        })
        if (compCollision) return true

        if (type !== 'WIRE') {
          for (let x = gx; x < gx + w; x++) {
            for (let y = gy; y < gy + h; y++) {
              if (wires.has(`${x},${y}`)) return true
            }
          }
        }

        return false
      }

      function render() {
        simulate()
        ctx.fillStyle = '#0f0f0f'
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        drawGrid()
        drawWires()
        for (const c of components) drawComponent(c)
        if (mode === 'DRAGGING_NEW' && newCompType) {
          drawComponent(
            { gx: mouseGrid.x, gy: mouseGrid.y, type: newCompType },
            true
          )
        }
      }

      function getGrid(clientPos) {
        return {
          x: Math.floor((clientPos.x - camera.x) / GRID_SIZE),
          y: Math.floor((clientPos.y - camera.y) / GRID_SIZE),
        }
      }

      function initHUD() {
        Object.keys(TOOLS).forEach((key) => {
          const def = TOOLS[key]
          const btn = document.createElement('button')
          const swatch = document.createElement('span')
          swatch.className = 'swatch'
          swatch.style.backgroundColor = def.color
          btn.appendChild(swatch)
          btn.appendChild(document.createTextNode(def.label))

          btn.onpointerdown = (e) => {
            e.preventDefault()
            e.stopPropagation()
            btn.setPointerCapture(e.pointerId)
            mode = 'DRAGGING_NEW'
            newCompType = key
            mouseGrid = getGrid({ x: e.clientX, y: e.clientY })
          }

          btn.onpointerup = (e) => {
            btn.releasePointerCapture(e.pointerId)
            if (mode === 'DRAGGING_NEW') {
              const g = getGrid({ x: e.clientX, y: e.clientY })
              if (newCompType === 'WIRE') {
                if (!checkCollision(g.x, g.y, 'WIRE'))
                  wires.set(`${g.x},${g.y}`, true)
              } else {
                if (!checkCollision(g.x, g.y, newCompType)) {
                  components.push(new Component(g.x, g.y, newCompType))
                }
              }
            }
            mode = 'IDLE'
            newCompType = null
          }
          hud.appendChild(btn)
        })

        const clearBtn = document.createElement('button')
        clearBtn.className = 'danger'
        clearBtn.innerText = 'Clear All'
        clearBtn.onclick = () => {
          if (confirm('Reset Board?')) {
            components = []
            wires.clear()
            wireStates.clear()
          }
        }
        hud.appendChild(clearBtn)
      }

      canvas.addEventListener('pointerdown', (e) => {
        const g = getGrid({ x: e.clientX, y: e.clientY })

        if (e.button === 2) {
          const hit = components.find(
            (c) =>
              g.x >= c.gx &&
              g.x < c.gx + TOOLS[c.type].w &&
              g.y >= c.gy &&
              g.y < c.gy + TOOLS[c.type].h
          )
          if (hit) components.splice(components.indexOf(hit), 1)
          else {
            wires.delete(`${g.x},${g.y}`)
            mode = 'ERASING'
          }
          return
        }

        const hit = components.find(
          (c) =>
            g.x >= c.gx &&
            g.x < c.gx + TOOLS[c.type].w &&
            g.y >= c.gy &&
            g.y < c.gy + TOOLS[c.type].h
        )

        if (hit) {
          if (hit.type === 'INPUT') {
            const screenX = hit.gx * GRID_SIZE + camera.x
            const screenY = hit.gy * GRID_SIZE + camera.y
            const cx = e.clientX - screenX
            const cy = e.clientY - screenY
            const pad = 10
            const w = TOOLS[hit.type].w * GRID_SIZE
            const h = TOOLS[hit.type].h * GRID_SIZE

            if (cx > pad && cx < w - pad && cy > pad && cy < h - pad) {
              hit.state = !hit.state
            } else {
              mode = 'DRAGGING_EXISTING'
              draggingComp = hit
              initialPos = { gx: hit.gx, gy: hit.gy }
              dragOffset = { x: g.x - hit.gx, y: g.y - hit.gy }
            }
          } else {
            mode = 'DRAGGING_EXISTING'
            draggingComp = hit
            initialPos = { gx: hit.gx, gy: hit.gy }
            dragOffset = { x: g.x - hit.gx, y: g.y - hit.gy }
          }
        } else if (wires.has(`${g.x},${g.y}`)) {
          mode = 'DRAGGING_WIRE'
          draggingWire = `${g.x},${g.y}`
          wires.delete(draggingWire)
        } else {
          mode = 'PANNING'
          dragStart = { x: e.clientX - camera.x, y: e.clientY - camera.y }
        }
      })

      window.addEventListener('pointermove', (e) => {
        const g = getGrid({ x: e.clientX, y: e.clientY })
        mouseGrid = g
        if (mode === 'PANNING') {
          camera.x = e.clientX - dragStart.x
          camera.y = e.clientY - dragStart.y
        } else if (mode === 'DRAGGING_EXISTING' && draggingComp) {
          draggingComp.gx = g.x - dragOffset.x
          draggingComp.gy = g.y - dragOffset.y
        } else if (mode === 'DRAGGING_WIRE') {
        } else if (mode === 'ERASING') {
          wires.delete(`${g.x},${g.y}`)
        }
      })

      window.addEventListener('pointerup', () => {
        if (mode === 'DRAGGING_EXISTING' && draggingComp) {
          if (
            checkCollision(
              draggingComp.gx,
              draggingComp.gy,
              draggingComp.type,
              draggingComp.id
            )
          ) {
            draggingComp.gx = initialPos.gx
            draggingComp.gy = initialPos.gy
          }
        }
        if (mode === 'DRAGGING_WIRE') {
          if (!checkCollision(mouseGrid.x, mouseGrid.y, 'WIRE')) {
            wires.set(`${mouseGrid.x},${mouseGrid.y}`, true)
          } else {
            wires.set(draggingWire, true)
          }
        }
        if (mode !== 'DRAGGING_NEW') mode = 'IDLE'
        draggingComp = null
        draggingWire = null
      })

      window.addEventListener('contextmenu', (e) => e.preventDefault())
      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight
      })
      canvas.width = window.innerWidth
      canvas.height = window.innerHeight
      initHUD()
      function loop() {
        render()
        requestAnimationFrame(loop)
      }
      loop()
    </script>
  </body>
</html>
