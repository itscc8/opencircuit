<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>OpenCircuit</title>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;800&display=swap');

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        color-scheme: dark;
        user-select: none;
        font-family: 'JetBrains Mono', monospace;
      }

      body {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        background-color: #0f0f0f;
      }
      :root {
        --hud-offset: 200px;
      }

      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        touch-action: none;
        z-index: 1;
      }

      .hud {
        position: absolute;
        top: 15px;
        left: 15px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 12px;
        border: 1px solid #333;
        border-radius: 6px;
        background: rgba(15, 15, 15, 0.9);
        backdrop-filter: blur(8px);
        width: 180px;
        z-index: 10;
        max-height: calc(100vh - 30px);
        overflow-y: auto;
      }

      .hud::-webkit-scrollbar {
        width: 4px;
      }
      .hud::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
      }
      .hud::-webkit-scrollbar-thumb {
        background: #444;
        border-radius: 2px;
      }

      .hidden {
        display: none !important;
      }

      button {
        padding: 10px;
        background: #000;
        border: 1px solid #333;
        border-radius: 4px;
        color: #ccc;
        cursor: pointer;
        font-size: 12px;
        text-align: left;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: all 0.1s;
        flex-shrink: 0;
        outline: none;
      }

      button:hover {
        background: #252525;
        border-color: #444;
        color: #fff;
      }
      button:active {
        background: #333;
      }
      button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }
      .themed-input {
        background: #111827;
        border: 1px solid #334155;
        color: #cbd5f5;
        border-radius: 6px;
      }
      .themed-input:focus {
        outline: 1px solid #475569;
      }
      select.themed-input {
        padding: 8px;
      }
      input[type='range'].themed-input {
        width: 100%;
        height: 8px;
        accent-color: #a855f7;
      }
      input[type='range'].themed-input::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #a855f7;
        border: 1px solid #c084fc;
      }
      input[type='range'].themed-input::-moz-range-thumb {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #a855f7;
        border: 1px solid #c084fc;
      }
      button.danger {
        border-color: #522;
        color: #e55;
      }
      button.danger:hover {
        background: #311;
      }

      button.action {
        background: #112;
        border-color: #335;
        color: #aaf;
        justify-content: center;
      }
      button.action:hover {
        background: #224;
      }

      button.active {
        background: #333;
        border-color: #666;
        color: #fff;
        box-shadow: inset 0 0 0 1px #555;
      }

      .separator {
        height: 1px;
        background: #333;
        margin: 4px 0;
        flex-shrink: 0;
      }

      .swatch {
        width: 10px;
        height: 10px;
        border-radius: 2px;
        display: inline-block;
      }

      .modal-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.6);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 30;
      }

      .modal-backdrop.hidden {
        display: none;
      }

      .modal {
        background: #0f0f0f;
        border: 1px solid #333;
        border-radius: 8px;
        padding: 16px;
        width: min(880px, 95vw);
        box-shadow: 0 15px 50px rgba(0, 0, 0, 0.5);
        position: relative;
      }

      .modal .close {
        position: absolute;
        top: 8px;
        right: 8px;
        border-radius: 50%;
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid #333;
        background: #111;
        color: #fff;
        cursor: pointer;
      }

      .modal-tabs {
        display: flex;
        gap: 8px;
        margin-bottom: 12px;
      }

      .tab-button {
        flex: 1;
        justify-content: center;
      }

      .tab-button.active {
        background: #1f1f2a;
        border-color: #556;
        color: #fff;
      }

      .modal textarea {
        width: 100%;
        min-height: 220px;
        background: #0a0a0a;
        color: #e5e5e5;
        border: 1px solid #333;
        border-radius: 6px;
        padding: 12px;
        font-family: 'JetBrains Mono', monospace;
        resize: vertical;
      }

      .modal .divider {
        text-align: center;
        margin: 12px 0;
        color: #666;
        font-size: 12px;
      }

      .modal .actions {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        margin-top: 10px;
      }

      .badge {
        background: #1f2937;
        color: #cbd5f5;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 10px;
        border: 1px solid #334155;
      }

      .context-menu {
        position: fixed;
        background: #0f0f0f;
        border: 1px solid #333;
        border-radius: 6px;
        padding: 6px;
        z-index: 40;
        min-width: 160px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      }

      .context-menu.hidden {
        display: none;
      }

      .context-menu button {
        width: 100%;
        justify-content: flex-start;
      }

      #logic-analyzer {
        position: fixed;
        left: var(--hud-offset);
        bottom: 0;
        width: calc(100% - var(--hud-offset));
        height: 140px;
        background: #0a0a0f;
        border-top: 1px solid #222;
        z-index: 5;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <div class="hud" id="hud"></div>
    <canvas id="logic-analyzer"></canvas>

    <div class="modal-backdrop hidden" id="modal-backdrop">
      <div class="modal">
        <button class="close" id="modal-close" aria-label="Close modal">âœ•</button>
        <div class="modal-tabs">
          <button class="tab-button active" id="tab-save" data-tab="save">
            Save Project
          </button>
          <button class="tab-button" id="tab-load" data-tab="load">
            Load Project
          </button>
        </div>

        <div class="modal-content" data-tab="save">
          <textarea id="save-json" readonly></textarea>
          <div class="actions">
            <button id="copy-json">Copy JSON</button>
            <button id="download-json">Save as File</button>
          </div>
        </div>

        <div class="modal-content hidden" data-tab="load">
          <textarea
            id="load-json"
            placeholder="Paste JSON here..."
            aria-label="Load JSON"
          ></textarea>
          <div class="divider">--- OR ---</div>
          <input type="file" id="load-file" accept=".json" />
          <div class="actions">
            <button id="apply-load">Load Circuit</button>
          </div>
        </div>
      </div>
    </div>

    <div class="context-menu hidden" id="ctx-menu"></div>

    <script>
      const canvas = document.getElementById('canvas')
      const ctx = canvas.getContext('2d', { alpha: false })
      const hud = document.getElementById('hud')
      const laCanvas = document.getElementById('logic-analyzer')
      const laCtx = laCanvas.getContext('2d')

      const modalBackdrop = document.getElementById('modal-backdrop')
      const modalClose = document.getElementById('modal-close')
      const tabSave = document.getElementById('tab-save')
      const tabLoad = document.getElementById('tab-load')
      const saveTextarea = document.getElementById('save-json')
      const loadTextarea = document.getElementById('load-json')
      const loadFileInput = document.getElementById('load-file')
      const copyBtn = document.getElementById('copy-json')
      const downloadBtn = document.getElementById('download-json')
      const applyLoadBtn = document.getElementById('apply-load')
      const ctxMenu = document.getElementById('ctx-menu')

      const GRID_SIZE = 25
      const PORT_RADIUS = 6
      const MAX_BITS = 64
      const LOGIC_LOW = 0n
      const LOGIC_HIGH = 1n
      const DEFAULT_NET = "1'b0"
      const BLOB_CLEANUP_DELAY_MS = 500 // allow download to finish before revoking blob URLs
      const HUD_OFFSET =
        parseInt(getComputedStyle(document.documentElement).getPropertyValue('--hud-offset')) ||
        200
      const MAX_DRC_DISPLAY_COUNT = 5
      const BYTE_MASK = 0xff
      const BYTE_MASK_BIG = 0xffn

      let components = []
      let wires = []
      let camera = { x: 0, y: 0 }
      let mode = 'IDLE'
      let placingType = null
      let draggingComp = null
      let dragOffset = { x: 0, y: 0 }
      let dragStart = { x: 0, y: 0 }
      let mouseGrid = { x: 0, y: 0 }
      let draggingWireStart = null
      let hoverPort = null
      let draggingFromMenu = false
      let selectionStart = null
      let selectionEnd = null
      let selectedComponents = []
      let isPaused = false
      let ticksPerSecond = 30
      let tickTimer = null
      const probes = new Map()
      const customLibrary = {}
      let flowOffset = 0
      const logicAnalyzer = {
        enabled: true,
        triggerWire: null,
        triggered: true,
        cursor: null,
        maxSamples: 256,
      }
      const GATE_DELAYS = {
        INPUT: 0,
        OUTPUT: 0,
        SPLITTER: 0,
        MERGER: 0,
        NOT: 1,
        AND: 1,
        NAND: 1,
        OR: 1,
        NOR: 1,
        XOR: 1,
        XNOR: 1,
        DFF: 1,
        CLOCK: 0,
      }
      let simTime = 0
      const eventQueue = []
      const scheduledComponents = new Map()
      const MAX_EVENTS_PER_TICK = 5000
      let drcFindings = []

      function clampBits(value, fallback = 1) {
        const n = Number(value)
        if (!Number.isFinite(n)) return fallback
        return Math.min(MAX_BITS, Math.max(1, Math.floor(n)))
      }

      function maskValue(value, bits) {
        const b = BigInt(clampBits(bits))
        const mask = (1n << b) - 1n
        return BigInt(value ?? 0) & mask
      }

      function toBig(value) {
        return typeof value === 'bigint' ? value : BigInt(value ?? 0)
      }

      function makeId(prefix) {
        return `${prefix}_${Math.random().toString(36).slice(2, 9)}`
      }

      function gateDelay(type) {
        return GATE_DELAYS[type] ?? 1
      }

      function resetSimulationClock() {
        simTime = 0
        eventQueue.length = 0
        scheduledComponents.clear()
      }

      function queueComponent(comp, delay = gateDelay(comp?.type)) {
        if (!comp) return
        const time = simTime + Math.max(0, delay)
        const existing = scheduledComponents.get(comp.id)
        if (existing !== undefined && existing <= time) return
        scheduledComponents.set(comp.id, time)
        eventQueue.push({ time, compId: comp.id })
      }

      function processEventsUntil(targetTime) {
        let processed = 0
        while (eventQueue.length) {
          eventQueue.sort((a, b) => a.time - b.time)
          const next = eventQueue[0]
          if (!next || next.time > targetTime) break
          if (processed++ > MAX_EVENTS_PER_TICK) break
          const evt = eventQueue.shift()
          const expected = scheduledComponents.get(evt.compId)
          if (expected !== evt.time) continue
          scheduledComponents.delete(evt.compId)
          simTime = Math.max(simTime, evt.time)
          const comp = components.find((c) => c.id === evt.compId)
          if (comp) evaluateAndPropagate(comp)
        }
        simTime = Math.max(simTime, targetTime)
      }

      function evaluateAndPropagate(comp) {
        const inputs = comp.inputs.map((port) => {
          const wire = wires.find(
            (w) => w.toCompId === comp.id && w.toPortId === port.id
          )
          const val = maskValue(wire ? wire.value : port.value ?? 0n, port.bitWidth)
          port.value = val
          return val
        })
        const outputs = evaluateComponent(comp, inputs, { components, wires })
        if (comp.type === 'OUTPUT') {
          comp.isLit = (inputs[0] ?? 0n) !== 0n
        }
        let outputChanged = false
        comp.outputs.forEach((port, idx) => {
          const newVal = maskValue(outputs[idx] ?? 0n, port.bitWidth)
          if (port.value !== newVal) {
            port.value = newVal
            comp.currentValue = newVal
            comp.nextValue = newVal
            outputChanged = true
            wires.forEach((w) => {
              if (w.fromCompId === comp.id && w.fromPortId === port.id) {
                if (w.value !== newVal) {
                  w.frameToggles = (w.frameToggles || 0) + 1
                  w.value = newVal
                  const dest = components.find((c) => c.id === w.toCompId)
                  if (dest) queueComponent(dest, gateDelay(dest.type))
                }
                if (probes.has(w.id)) {
                  const probe = probes.get(w.id)
                  probe.history.push(newVal)
                  if (probe.history.length > 50) probe.history.shift()
                }
              }
            })
          }
        })
        if (comp.inputs.length === 0 && comp.outputs.length) {
          queueComponent(comp, gateDelay(comp.type))
        }
      }

      function syncNamedNet(wire, value) {
        if (!wire?.netName) return
        wires.forEach((other) => {
          if (other === wire) return
          if (other.netName === wire.netName) {
            if (other.value !== value) {
              other.value = value
              const dest = components.find((c) => c.id === other.toCompId)
              if (dest) queueComponent(dest, gateDelay(dest.type))
            }
          }
        })
      }

      function ensureMemory(comp) {
        if (!comp) return null
        const size = Math.max(1, Math.floor(comp.properties?.size || 1))
        if (!(comp.memory instanceof Uint8Array) || comp.memory.length !== size) {
          comp.memory = new Uint8Array(size)
        }
        return comp.memory
      }

      function memoryToHex(comp) {
        ensureMemory(comp)
        return Array.from(comp.memory || [])
          .map((b) => b.toString(16).padStart(2, '0'))
          .join(' ')
      }

      function hexToBytes(input) {
        if (!input) return []
        return input
          .trim()
          .split(/\s+/)
          .filter(Boolean)
          .map((v) => parseInt(v, 16) & BYTE_MASK)
          .filter((n) => Number.isFinite(n))
      }

      function calculateMemoryAddress(input, memoryLength) {
        const len = Math.max(1, memoryLength || 1)
        const raw = Math.abs(Number(toBig(input) ?? 0n))
        if (!Number.isFinite(raw)) return 0
        return raw % len
      }

      function openHexEditor(comp) {
        if (!comp) return
        ensureMemory(comp)
        const current = memoryToHex(comp)
        const next = prompt(`Edit ${comp.type} ${comp.id} (hex bytes)`, current)
        if (next === null) return
        const bytes = hexToBytes(next)
        comp.memory.fill(0)
        comp.memory.set(bytes.slice(0, comp.memory.length))
        queueComponent(comp, 0)
      }

      function runDRC() {
        const warnings = []
        const driverMap = new Map()
        wires.forEach((w) => {
          const netKey = w.netName ? `net:${w.netName}` : `wire:${w.id}`
          const srcKey = `${w.fromCompId}:${w.fromPortId}`
          if (!driverMap.has(netKey)) driverMap.set(netKey, new Set())
          driverMap.get(netKey).add(srcKey)
          const fromPort = getPort(w.fromCompId, w.fromPortId)
          const toPort = getPort(w.toCompId, w.toPortId)
          if (fromPort && toPort && fromPort.bitWidth !== toPort.bitWidth) {
            warnings.push({
              type: 'width_mismatch',
              message: `Width mismatch on wire ${w.id}`,
              location: w.id,
            })
          }
        })

        driverMap.forEach((drivers, key) => {
          if (key.startsWith('net:') && drivers.size > 1) {
            warnings.push({
              type: 'short_circuit',
              message: `Multiple drivers detected on ${key.slice(4)}`,
              location: key,
            })
          }
        })

        components.forEach((c) => {
          c.inputs.forEach((p) => {
            const connected = wires.some(
              (w) => w.toCompId === c.id && w.toPortId === p.id
            )
            if (!connected) {
              warnings.push({
                type: 'floating_input',
                message: `Floating input ${c.id}:${p.id}`,
                location: c.id,
              })
            }
          })
          c.outputs.forEach((p) => {
            const connected = wires.some(
              (w) => w.fromCompId === c.id && w.fromPortId === p.id
            )
            if (!connected) {
              warnings.push({
                type: 'unconnected_output',
                message: `Unconnected output ${c.id}:${p.id}`,
                location: c.id,
              })
            }
          })
        })
        drcFindings = warnings
        return warnings
      }

      function seedInitialEvents() {
        scheduledComponents.clear()
        eventQueue.length = 0
        components.forEach((c) => queueComponent(c, 0))
      }

      class Port {
        constructor({ id, parentId, type, relativeX, relativeY, bitWidth = 1 }) {
          this.id = id
          this.parentId = parentId
          this.type = type
          this.relativeX = relativeX
          this.relativeY = relativeY
          this.bitWidth = clampBits(bitWidth)
          this.value = 0n
          this.nextValue = 0n
        }
      }

      class Wire {
        constructor({
          id,
          fromCompId,
          fromPortId,
          toCompId,
          toPortId,
          bitWidth,
          netName = null,
          path = null,
          pathIsGrid = false,
        }) {
          this.id = id || makeId('wire')
          this.fromCompId = fromCompId
          this.fromPortId = fromPortId
          this.toCompId = toCompId
          this.toPortId = toPortId
          this.bitWidth = clampBits(bitWidth)
          this.value = 0n
          this.frameToggles = 0
          this.showFlow = false
          this.netName = netName || null
          this.path = path || null
          this.pathIsGrid = !!pathIsGrid
        }
      }

      class Component {
        constructor(gx, gy, type, properties = {}) {
          this.gx = gx
          this.gy = gy
          this.type = type
          this.id = makeId('cmp')
          this.state = false
          this.isLit = false
          this.overrideValue = null
          this.currentValue = 0n
          this.nextValue = 0n
          this.properties = {
            ...(TOOLS[type]?.defaultProperties || {}),
            ...properties,
          }
          this.inputs = []
          this.outputs = []
          this.w = TOOLS[type]?.w || 2
          this.h = TOOLS[type]?.h || 2
          configureComponent(this)
        }
      }

      function configureComponent(comp) {
        const def = TOOLS[comp.type]
        if (!def) return
        comp.inputs = []
        comp.outputs = []
        comp.w = def.w
        comp.h = def.h
        def.setup(comp)
        pruneWiresForComponent(comp)
        queueComponent(comp, 0)
      }

      const TOOLS = {
        INPUT: {
          label: 'IN',
          color: '#3b82f6',
          w: 2,
          h: 2,
          defaultProperties: { bitWidth: 1 },
          setup: (c) => {
            const bits = clampBits(c.properties.bitWidth || 1)
            c.properties.bitWidth = bits
            c.outputs = [
              new Port({
                id: 'out',
                parentId: c.id,
                type: 'OUT',
                relativeX: c.w,
                relativeY: c.h / 2,
                bitWidth: bits,
              }),
            ]
          },
        },
        OUTPUT: {
          label: 'OUT',
          color: '#22c55e',
          w: 2,
          h: 2,
          defaultProperties: { bitWidth: 1 },
          setup: (c) => {
            const bits = clampBits(c.properties.bitWidth || 1)
            c.properties.bitWidth = bits
            c.inputs = [
              new Port({
                id: 'in',
                parentId: c.id,
                type: 'IN',
                relativeX: 0,
                relativeY: c.h / 2,
                bitWidth: bits,
              }),
            ]
          },
        },
        NOT: {
          label: 'NOT',
          color: '#ef4444',
          w: 2,
          h: 2,
          defaultProperties: { bitWidth: 1 },
          setup: (c) => {
            const bits = clampBits(c.properties.bitWidth || 1)
            c.properties.bitWidth = bits
            c.inputs = [
              new Port({
                id: 'in',
                parentId: c.id,
                type: 'IN',
                relativeX: 0,
                relativeY: c.h / 2,
                bitWidth: bits,
              }),
            ]
            c.outputs = [
              new Port({
                id: 'out',
                parentId: c.id,
                type: 'OUT',
                relativeX: c.w,
                relativeY: c.h / 2,
                bitWidth: bits,
              }),
            ]
          },
        },
        AND: {
          label: 'AND',
          color: '#eab308',
          w: 2.5,
          h: 2,
          defaultProperties: { bitWidth: 1 },
          setup: (c) => {
            const bits = clampBits(c.properties.bitWidth || 1)
            c.properties.bitWidth = bits
            c.inputs = [
              new Port({
                id: 'in0',
                parentId: c.id,
                type: 'IN',
                relativeX: 0,
                relativeY: 0.6,
                bitWidth: bits,
              }),
              new Port({
                id: 'in1',
                parentId: c.id,
                type: 'IN',
                relativeX: 0,
                relativeY: c.h - 0.6,
                bitWidth: bits,
              }),
            ]
            c.outputs = [
              new Port({
                id: 'out',
                parentId: c.id,
                type: 'OUT',
                relativeX: c.w,
                relativeY: c.h / 2,
                bitWidth: bits,
              }),
            ]
          },
        },
        NAND: {
          label: 'NAND',
          color: '#14b8a6',
          w: 2.5,
          h: 2,
          defaultProperties: { bitWidth: 1 },
          setup: (c) => TOOLS.AND.setup(c),
        },
        OR: {
          label: 'OR',
          color: '#a855f7',
          w: 2.5,
          h: 2,
          defaultProperties: { bitWidth: 1 },
          setup: (c) => TOOLS.AND.setup(c),
        },
        NOR: {
          label: 'NOR',
          color: '#f97316',
          w: 2.5,
          h: 2,
          defaultProperties: { bitWidth: 1 },
          setup: (c) => TOOLS.AND.setup(c),
        },
        XOR: {
          label: 'XOR',
          color: '#ec4899',
          w: 2.5,
          h: 2,
          defaultProperties: { bitWidth: 1 },
          setup: (c) => TOOLS.AND.setup(c),
        },
        XNOR: {
          label: 'XNOR',
          color: '#6366f1',
          w: 2.5,
          h: 2,
          defaultProperties: { bitWidth: 1 },
          setup: (c) => TOOLS.AND.setup(c),
        },
        DFF: {
          label: 'DFF',
          color: '#22c55e',
          w: 2.5,
          h: 2,
          defaultProperties: { bitWidth: 1 },
          setup: (c) => {
            const bits = clampBits(c.properties.bitWidth || 1)
            c.properties.bitWidth = bits
            c.inputs = [
              new Port({
                id: 'd',
                parentId: c.id,
                type: 'IN',
                relativeX: 0,
                relativeY: 0.8,
                bitWidth: bits,
              }),
              new Port({
                id: 'clk',
                parentId: c.id,
                type: 'IN',
                relativeX: 0,
                relativeY: c.h - 0.8,
                bitWidth: 1,
              }),
            ]
            c.outputs = [
              new Port({
                id: 'q',
                parentId: c.id,
                type: 'OUT',
                relativeX: c.w,
                relativeY: c.h / 2,
                bitWidth: bits,
              }),
            ]
            c.stateValue = 0n
            c.lastClock = 0n
            c.properties.selfSchedule = !!c.properties.selfSchedule
          },
        },
        CLOCK: {
          label: 'CLK',
          color: '#67e8f9',
          w: 2,
          h: 2,
          defaultProperties: { bitWidth: 1, period: 2 },
          setup: (c) => {
            const period = Math.max(1, Math.floor(c.properties.period || 2))
            c.properties.period = period
            c.clockPhase = c.clockPhase ?? 0
            c.outputs = [
              new Port({
                id: 'out',
                parentId: c.id,
                type: 'OUT',
                relativeX: c.w,
                relativeY: c.h / 2,
                bitWidth: 1,
              }),
            ]
            c.inputs = []
          },
        },
        ROM: {
          label: 'ROM',
          color: '#facc15',
          w: 3,
          h: 3,
          defaultProperties: { bitWidth: 8, size: 64 },
          setup: (c) => {
            const bits = clampBits(c.properties.bitWidth || 8)
            const size = Math.max(1, Math.floor(c.properties.size || 64))
            c.properties.bitWidth = bits
            c.properties.size = size
            c.properties.addrWidth = clampBits(Math.ceil(Math.log2(size)) || 1, 1)
            ensureMemory(c)
            c.inputs = [
              new Port({
                id: 'addr',
                parentId: c.id,
                type: 'IN',
                relativeX: 0,
                relativeY: c.h / 2,
                bitWidth: c.properties.addrWidth,
              }),
            ]
            c.outputs = [
              new Port({
                id: 'data',
                parentId: c.id,
                type: 'OUT',
                relativeX: c.w,
                relativeY: c.h / 2,
                bitWidth: bits,
              }),
            ]
          },
        },
        RAM: {
          label: 'RAM',
          color: '#4ade80',
          w: 3,
          h: 3,
          defaultProperties: { bitWidth: 8, size: 64 },
          setup: (c) => {
            const bits = clampBits(c.properties.bitWidth || 8)
            const size = Math.max(1, Math.floor(c.properties.size || 64))
            const addrWidth = clampBits(Math.ceil(Math.log2(size)) || 1)
            c.properties.bitWidth = bits
            c.properties.size = size
            c.properties.addrWidth = addrWidth
            ensureMemory(c)
            c.lastClock = c.lastClock ?? 0n
            c.inputs = [
              new Port({
                id: 'addr',
                parentId: c.id,
                type: 'IN',
                relativeX: 0,
                relativeY: c.h / 2 - 0.6,
                bitWidth: addrWidth,
              }),
              new Port({
                id: 'data_in',
                parentId: c.id,
                type: 'IN',
                relativeX: 0,
                relativeY: c.h / 2 + 0.6,
                bitWidth: bits,
              }),
              new Port({
                id: 'we',
                parentId: c.id,
                type: 'IN',
                relativeX: 0,
                relativeY: c.h - 0.6,
                bitWidth: 1,
              }),
              new Port({
                id: 'clk',
                parentId: c.id,
                type: 'IN',
                relativeX: 0,
                relativeY: 0.6,
                bitWidth: 1,
              }),
            ]
            c.outputs = [
              new Port({
                id: 'data',
                parentId: c.id,
                type: 'OUT',
                relativeX: c.w,
                relativeY: c.h / 2,
                bitWidth: bits,
              }),
            ]
          },
        },
        SPLITTER: {
          label: 'SPLIT',
          color: '#0ea5e9',
          w: 2,
          h: 2,
          defaultProperties: { busSize: 8 },
          setup: (c) => {
            const count =
              clampBits(c.properties.busSize ?? c.properties.outputs ?? 8) || 8
            c.properties.busSize = count
            c.h = Math.max(2, count)
            const spacing = c.h / (count + 1)
            c.inputs = [
              new Port({
                id: 'in',
                parentId: c.id,
                type: 'IN',
                relativeX: 0,
                relativeY: c.h / 2,
                bitWidth: count,
              }),
            ]
            c.outputs = []
            for (let i = 0; i < count; i++) {
              c.outputs.push(
                new Port({
                  id: `out${i}`,
                  parentId: c.id,
                  type: 'OUT',
                  relativeX: c.w,
                  relativeY: spacing * (i + 1),
                  bitWidth: 1,
                })
              )
            }
          },
        },
        MERGER: {
          label: 'MERGE',
          color: '#f59e0b',
          w: 2,
          h: 2,
          defaultProperties: { busSize: 8 },
          setup: (c) => {
            const count =
              clampBits(c.properties.busSize ?? c.properties.inputs ?? 8) || 8
            c.properties.busSize = count
            c.h = Math.max(2, count)
            const spacing = c.h / (count + 1)
            c.inputs = []
            for (let i = 0; i < count; i++) {
              c.inputs.push(
                new Port({
                  id: `in${i}`,
                  parentId: c.id,
                  type: 'IN',
                  relativeX: 0,
                  relativeY: spacing * (i + 1),
                  bitWidth: 1,
                })
              )
            }
            c.outputs = [
              new Port({
                id: 'out',
                parentId: c.id,
                type: 'OUT',
                relativeX: c.w,
                relativeY: c.h / 2,
                bitWidth: count,
              }),
            ]
          },
        },
      }

      function resolveParamValue(value, params = {}) {
        if (typeof value === 'function') {
          return clampBits(value(params))
        }
        if (typeof value === 'string') {
          const key = value.startsWith('$') ? value.slice(1) : null
          if (key && params[key] !== undefined) return clampBits(params[key])
          const asNum = Number(value)
          if (Number.isFinite(asNum)) return clampBits(asNum)
        }
        return clampBits(value ?? 1)
      }

      function registerCustomTool(def) {
        const ins = def.inputs.length
        const outs = def.outputs.length
        const height = Math.max(2, ins, outs)
        const hue = Math.floor(Math.random() * 360)
        TOOLS[def.name] = {
          label: def.name,
          color: `hsl(${hue},70%,65%)`,
          w: 3,
          h: height,
          defaultProperties: { parameters: { ...(def.parameters || {}) } },
          setup: (c) => {
            const params = {
              ...(def.parameters || {}),
              ...(c.properties.parameters || c.properties.params || {}),
            }
            c.parameters = params
            c.w = 3
            c.h = height
            c.inputs = def.inputs.map((p, idx) => {
              const bw = resolveParamValue(p.bitWidth, params)
              return new Port({
                id: `in${idx}`,
                parentId: c.id,
                type: 'IN',
                relativeX: 0,
                relativeY: (idx + 1) * (c.h / (ins + 1)),
                bitWidth: bw,
              })
            })
            c.outputs = def.outputs.map((p, idx) => {
              const bw = resolveParamValue(p.bitWidth, params)
              return new Port({
                id: `out${idx}`,
                parentId: c.id,
                type: 'OUT',
                relativeX: c.w,
                relativeY: (idx + 1) * (c.h / (outs + 1)),
                bitWidth: bw,
              })
            })
            c.customName = def.name
          },
        }
        customLibrary[def.name] = { ...def, parameters: { ...(def.parameters || {}) } }
      }

      function componentAt(gridX, gridY) {
        return components.find(
          (c) =>
            gridX >= c.gx &&
            gridX <= c.gx + c.w &&
            gridY >= c.gy &&
            gridY <= c.gy + c.h
        )
      }

      function checkCollision(gx, gy, type, excludeId = null) {
        const def = TOOLS[type]
        if (!def) return false
        const w = def.w
        const h = def.h
        return components.some((c) => {
          if (c.id === excludeId) return false
          return (
            gx < c.gx + c.w &&
            gx + w > c.gx &&
            gy < c.gy + c.h &&
            gy + h > c.gy
          )
        })
      }

      function getPort(compId, portId) {
        const comp = components.find((c) => c.id === compId)
        if (!comp) return null
        return [...comp.inputs, ...comp.outputs].find((p) => p.id === portId)
      }

      function portPosition(comp, port) {
        return {
          x: (comp.gx + port.relativeX) * GRID_SIZE + camera.x,
          y: (comp.gy + port.relativeY) * GRID_SIZE + camera.y,
        }
      }

      function hitTestPort(clientX, clientY) {
        let hit = null
        components.forEach((comp) => {
          const ports = [...comp.inputs, ...comp.outputs]
          ports.forEach((port) => {
            const pos = portPosition(comp, port)
            const dx = clientX - pos.x
            const dy = clientY - pos.y
            if (Math.hypot(dx, dy) <= PORT_RADIUS + 4) {
              hit = { component: comp, port }
            }
          })
        })
        return hit
      }

      function pruneWiresForComponent(comp) {
        const inIds = new Set(comp.inputs.map((p) => p.id))
        const outIds = new Set(comp.outputs.map((p) => p.id))
        wires = wires.filter((w) => {
          if (w.toCompId === comp.id && !inIds.has(w.toPortId)) return false
          if (w.fromCompId === comp.id && !outIds.has(w.fromPortId)) return false
          const fromPort = getPort(w.fromCompId, w.fromPortId)
          const toPort = getPort(w.toCompId, w.toPortId)
          if (!fromPort || !toPort) return false
          return fromPort.bitWidth === toPort.bitWidth
        })
      }

      function tryConnectPorts(a, b) {
        let from = a
        let to = b
        if (a.port.type === 'IN' && b.port.type === 'OUT') {
          from = b
          to = a
        }
        if (from.port.type !== 'OUT' || to.port.type !== 'IN') return
        if (from.component.id === to.component.id) return
        if (from.port.bitWidth !== to.port.bitWidth) {
          alert('Bit-widths must match to connect these ports.')
          return
        }

        wires = wires.filter(
          (w) => !(w.toCompId === to.component.id && w.toPortId === to.port.id)
        )

        wires.push(
          new Wire({
            fromCompId: from.component.id,
            fromPortId: from.port.id,
            toCompId: to.component.id,
            toPortId: to.port.id,
            bitWidth: from.port.bitWidth,
          })
        )
        applyAutoRoute(wires[wires.length - 1])
        queueComponent(to.component, gateDelay(to.component.type))
      }

      function removeComponent(comp) {
        wires = wires.filter((w) => {
          const keep = w.fromCompId !== comp.id && w.toCompId !== comp.id
          if (!keep) {
            probes.delete(w.id)
            const dest = components.find((c) => c.id === w.toCompId)
            if (dest) queueComponent(dest, gateDelay(dest.type))
          }
          return keep
        })
        const idx = components.indexOf(comp)
        if (idx >= 0) components.splice(idx, 1)
      }

      function runTickFor(comps, wireList) {
        const context = { components: comps, wires: wireList }
        comps.forEach((c) => {
          c.isLit = false
        })

        comps.forEach((comp) => {
          const inputs = comp.inputs.map((port) => {
            const wire = wireList.find(
              (w) => w.toCompId === comp.id && w.toPortId === port.id
            )
            const val = maskValue(wire ? wire.value : port.value ?? 0n, port.bitWidth)
            port.value = val
            return val
          })
          const outputs = evaluateComponent(comp, inputs, context)
          comp.outputs.forEach((port, idx) => {
            port.nextValue = maskValue(outputs[idx] ?? 0n, port.bitWidth)
          })
        })

        comps.forEach((comp) => {
          comp.outputs.forEach((port) => {
            comp.currentValue = port.value
            comp.nextValue = port.nextValue ?? 0n
            port.value = port.nextValue ?? 0n
          })
        })

        wireList.forEach((wire) => {
          const fromComp = comps.find((c) => c.id === wire.fromCompId)
          const fromPort = fromComp?.outputs.find((p) => p.id === wire.fromPortId)
          const newVal = fromPort ? maskValue(fromPort.value, wire.bitWidth) : 0n
          if (wire.value !== newVal) {
            wire.frameToggles = (wire.frameToggles || 0) + 1
          }
          wire.value = newVal
          syncNamedNet(wire, newVal)
          if (probes.has(wire.id)) {
            const probe = probes.get(wire.id)
            probe.history.push(newVal)
            if (probe.history.length > 50) probe.history.shift()
          }
        })
      }

      function tickOnce() {
        const target = simTime + 1
        processEventsUntil(target)
        sampleProbes()
      }

      function tick(count = 1) {
        for (let i = 0; i < count; i++) tickOnce()
      }

      function evaluateComponent(comp, inputs, context) {
        switch (comp.type) {
          case 'INPUT': {
            const bits = comp.outputs[0]?.bitWidth || 1
            const high = (1n << BigInt(bits)) - 1n
            if (comp.overrideValue !== null && comp.overrideValue !== undefined) {
              return [maskValue(comp.overrideValue, bits)]
            }
            return [comp.state ? high : 0n]
          }
          case 'OUTPUT': {
            comp.isLit = (inputs[0] ?? 0n) !== 0n
            return []
          }
          case 'NOT': {
            const port = comp.outputs[0]
            const result = ~toBig(inputs[0] ?? 0n)
            return [maskValue(result, port?.bitWidth || 1)]
          }
          case 'AND': {
            const port = comp.outputs[0]
            const val = inputs.reduce(
              (acc, cur) => acc & toBig(cur ?? 0n),
              toBig(inputs[0] ?? 0n)
            )
            return [maskValue(val, port?.bitWidth || 1)]
          }
          case 'NAND': {
            const [res] = evaluateComponent(
              { ...comp, type: 'AND' },
              inputs
            )
            const port = comp.outputs[0]
            return [maskValue(~toBig(res ?? 0n), port?.bitWidth || 1)]
          }
          case 'OR': {
            const port = comp.outputs[0]
            const val = inputs.reduce(
              (acc, cur) => acc | toBig(cur ?? 0n),
              toBig(inputs[0] ?? 0n)
            )
            return [maskValue(val, port?.bitWidth || 1)]
          }
          case 'NOR': {
            const [res] = evaluateComponent({ ...comp, type: 'OR' }, inputs)
            const port = comp.outputs[0]
            return [maskValue(~toBig(res ?? 0n), port?.bitWidth || 1)]
          }
          case 'XOR': {
            const port = comp.outputs[0]
            const val = inputs.reduce(
              (acc, cur) => acc ^ toBig(cur ?? 0n),
              toBig(inputs[0] ?? 0n)
            )
            return [maskValue(val, port?.bitWidth || 1)]
          }
          case 'XNOR': {
            const [res] = evaluateComponent({ ...comp, type: 'XOR' }, inputs)
            const port = comp.outputs[0]
            return [maskValue(~toBig(res ?? 0n), port?.bitWidth || 1)]
          }
          case 'SPLITTER': {
            const inputVal = toBig(inputs[0] ?? 0n)
            return comp.outputs.map((_, idx) =>
              maskValue(inputVal >> BigInt(idx), 1)
            )
          }
          case 'MERGER': {
            let value = 0n
            comp.inputs.forEach((_, idx) => {
              if ((toBig(inputs[idx] ?? 0n) & 1n) === 1n) {
                value |= 1n << BigInt(idx)
              }
            })
            return [maskValue(value, comp.properties.busSize || 1)]
          }
          case 'DFF': {
            const dVal = maskValue(inputs[0] ?? 0n, comp.outputs[0]?.bitWidth || 1)
            const clk = inputs[1] ?? 0n
            const rising = clk !== 0n && comp.lastClock === 0n
            if (rising) {
              comp.stateValue = dVal
            }
            comp.lastClock = clk
            return [comp.stateValue ?? 0n]
          }
          case 'ROM': {
            const mem = ensureMemory(comp)
            const addr = calculateMemoryAddress(inputs[0], mem.length)
            const byte = BigInt(mem[addr] || 0)
            const width = comp.outputs[0]?.bitWidth || 8
            return [maskValue(byte, width)]
          }
          case 'RAM': {
            const mem = ensureMemory(comp)
            const addr = calculateMemoryAddress(inputs[0], mem.length)
            const dataIn = maskValue(inputs[1] ?? 0n, comp.properties.bitWidth || 8)
            const we = inputs[2] ?? 0n
            const clk = inputs[3] ?? 0n
            const rising = clk !== 0n && comp.lastClock === 0n
            if (rising && we !== 0n) {
              mem[addr] = Number(dataIn & BYTE_MASK_BIG)
            }
            comp.lastClock = clk
            const byte = BigInt(mem[addr] || 0)
            const width = comp.outputs[0]?.bitWidth || 8
            return [maskValue(byte, width)]
          }
          case 'CLOCK': {
            const period = Math.max(1, Math.floor(comp.properties.period || 2))
            comp.clockPhase = (comp.clockPhase + 1) % period
            const highFor = Math.max(1, Math.floor(period / 2))
            const val = comp.clockPhase < highFor ? 1n : 0n
            return [val]
          }
          default: {
            if (customLibrary[comp.type]) {
              return evaluateCustomComponent(comp, inputs, context)
            }
            return []
          }
        }
      }

      function cloneCustomInstance(def, params = {}) {
        const compMap = new Map()
        const comps = def.components.map((c) => {
          const props = { ...(c.properties || {}) }
          if (typeof props.bitWidth === 'string') {
            props.bitWidth = resolveParamValue(props.bitWidth, params)
          }
          if (typeof props.busSize === 'string') {
            props.busSize = resolveParamValue(props.busSize, params)
          }
          props.parameters = { ...(props.parameters || {}), ...params }
          const inst = new Component(c.gx, c.gy, c.type, props)
          inst.id = c.id
          compMap.set(c.id, inst)
          return inst
        })
        const wList = def.wires.map((w) => ({
          ...w,
          value: 0n,
          frameToggles: 0,
        }))
        return { components: comps, wires: wList }
      }

      function evaluateCustomComponent(comp, inputs, parentContext) {
        const def = customLibrary[comp.type]
        if (!def) return []
        if (!comp.subInstance) {
          comp.subInstance = cloneCustomInstance(def, comp.parameters || def.parameters || {})
        }
        const sub = comp.subInstance
        // inject inputs into mapped internal INPUT components
        def.inputs.forEach((p, idx) => {
          const target = sub.components.find((c) => c.id === p.componentId)
          if (target) target.overrideValue = inputs[idx] ?? 0n
        })
        runTickFor(sub.components, sub.wires)
        const outputs = def.outputs.map((p) => {
          const outComp = sub.components.find((c) => c.id === p.componentId)
          if (!outComp) return 0n
          const wire = sub.wires.find(
            (w) => w.toCompId === outComp.id && w.toPortId === 'in'
          )
          // fallback to the input buffer only when no wire connects (keeps legacy single-port OUTPUT defs working)
          const val = wire ? wire.value : outComp.inputs.find((i) => i.id === 'in')?.value
          return maskValue(val ?? 0n, p.bitWidth || outComp.inputs[0]?.bitWidth || 1)
        })
        return outputs
      }

      function stopTickLoop() {
        if (tickTimer) {
          clearInterval(tickTimer)
          tickTimer = null
        }
      }

      function setTickRate(hz) {
        const clamped = Math.max(1, Math.min(240, Math.floor(hz || 1)))
        ticksPerSecond = clamped
        startTickLoop()
        refreshHUD()
      }

      function startTickLoop() {
        stopTickLoop()
        tickTimer = setInterval(() => {
          if (!isPaused) tickOnce()
        }, 1000 / ticksPerSecond)
      }

      function pauseSimulation() {
        isPaused = true
        refreshHUD()
      }

      function resumeSimulation() {
        isPaused = false
        refreshHUD()
      }

      function togglePause() {
        isPaused = !isPaused
        refreshHUD()
      }

      function stepSimulation(count = 1) {
        const prev = isPaused
        isPaused = true
        tick(count)
        isPaused = prev
      }

      function getGrid(clientPos) {
        return {
          x: Math.floor((clientPos.x - camera.x) / GRID_SIZE),
          y: Math.floor((clientPos.y - camera.y) / GRID_SIZE),
        }
      }

      function drawGrid() {
        ctx.strokeStyle = '#1f1f1f'
        ctx.lineWidth = 1

        const startX = ((-camera.x / GRID_SIZE) | 0) * GRID_SIZE + camera.x
        const startY = ((-camera.y / GRID_SIZE) | 0) * GRID_SIZE + camera.y

        for (let x = startX; x < canvas.width; x += GRID_SIZE) {
          ctx.beginPath()
          ctx.moveTo(x, 0)
          ctx.lineTo(x, canvas.height)
          ctx.stroke()
        }

        for (let y = startY; y < canvas.height; y += GRID_SIZE) {
          ctx.beginPath()
          ctx.moveTo(0, y)
          ctx.lineTo(canvas.width, y)
          ctx.stroke()
        }
      }

      function drawBadge(x, y, text, color) {
        const pad = 6
        ctx.fillStyle = color
        ctx.strokeStyle = '#0f0f0f'
        ctx.lineWidth = 1
        const width = ctx.measureText(text).width + pad * 2
        const height = 16
        const rx = 6
        const left = x - width / 2
        const top = y - height / 2
        ctx.beginPath()
        ctx.moveTo(left + rx, top)
        ctx.lineTo(left + width - rx, top)
        ctx.quadraticCurveTo(left + width, top, left + width, top + rx)
        ctx.lineTo(left + width, top + height - rx)
        ctx.quadraticCurveTo(
          left + width,
          top + height,
          left + width - rx,
          top + height
        )
        ctx.lineTo(left + rx, top + height)
        ctx.quadraticCurveTo(left, top + height, left, top + height - rx)
        ctx.lineTo(left, top + rx)
        ctx.quadraticCurveTo(left, top, left + rx, top)
        ctx.closePath()
        ctx.fill()
        ctx.stroke()
        ctx.fillStyle = '#fff'
        ctx.font = '10px "JetBrains Mono"'
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'
        ctx.fillText(text, x, y)
      }

      function wireColor(wire) {
        return wire.bitWidth > 7 ? '#f97316' : '#3b82f6'
      }

      function applyAutoRoute(wire) {
        const fromComp = components.find((c) => c.id === wire.fromCompId)
        const toComp = components.find((c) => c.id === wire.toCompId)
        if (!fromComp || !toComp) return
        const fromPort = fromComp.outputs.find((p) => p.id === wire.fromPortId)
        const toPort = toComp.inputs.find((p) => p.id === wire.toPortId)
        if (!fromPort || !toPort) return
        const start = {
          x: fromComp.gx + fromPort.relativeX,
          y: fromComp.gy + fromPort.relativeY,
        }
        const end = { x: toComp.gx + toPort.relativeX, y: toComp.gy + toPort.relativeY }
        // Use a simple orthogonal L-shaped route to keep paths grid-aligned
        const path = [
          { x: start.x, y: start.y },
          { x: start.x, y: end.y },
          { x: end.x, y: end.y },
        ]
        wire.path = path
        wire.pathIsGrid = true
      }

      function rerouteForComponent(comp) {
        wires.forEach((w) => {
          if (w.fromCompId === comp.id || w.toCompId === comp.id) {
            applyAutoRoute(w)
          }
        })
      }

      function drawWires() {
        wires.forEach((wire) => {
          drawWire(wire)
        })

        if (draggingWireStart) {
          const start = portPosition(
            draggingWireStart.component,
            draggingWireStart.port
          )
          const end = hoverPort
            ? portPosition(hoverPort.component, hoverPort.port)
            : {
                x: mouseGrid.x * GRID_SIZE + camera.x,
                y: mouseGrid.y * GRID_SIZE + camera.y,
              }
          ctx.strokeStyle = '#888'
          ctx.lineWidth = 2
          ctx.beginPath()
          ctx.moveTo(start.x, start.y)
          ctx.lineTo(end.x, end.y)
          ctx.stroke()
        }
        drawProbes()
      }

      function drawWire(wire) {
        const fromComp = components.find((c) => c.id === wire.fromCompId)
        const toComp = components.find((c) => c.id === wire.toCompId)
        if (!fromComp || !toComp) return
        const fromPort = fromComp.outputs.find((p) => p.id === wire.fromPortId)
        const toPort = toComp.inputs.find((p) => p.id === wire.toPortId)
        if (!fromPort || !toPort) return
        const start = portPosition(fromComp, fromPort)
        const end = portPosition(toComp, toPort)
        const active = wire.value !== 0n
        const toggled = (wire.frameToggles || 0) > 1

        ctx.strokeStyle = toggled ? '#a855f7' : active ? '#fffa8b' : wireColor(wire)
        ctx.lineWidth = toggled || active ? 3 : 2
        if (wire.showFlow) {
          ctx.setLineDash([12, 10])
          ctx.lineDashOffset = -flowOffset
        }
        ctx.lineCap = 'round'
        ctx.beginPath()
        const rawPoints =
          Array.isArray(wire.path) && wire.path.length ? wire.path : [start, end]
        const pathPoints = rawPoints.map((p) =>
          wire.pathIsGrid
            ? { x: p.x * GRID_SIZE + camera.x, y: p.y * GRID_SIZE + camera.y }
            : p
        )
        ctx.moveTo(pathPoints[0].x, pathPoints[0].y)
        for (let i = 1; i < pathPoints.length; i++) {
          ctx.lineTo(pathPoints[i].x, pathPoints[i].y)
        }
        ctx.stroke()
        if (wire.showFlow) {
          ctx.setLineDash([])
          ctx.lineDashOffset = 0
        }

        if (wire.bitWidth > 1) {
          const midX = (start.x + end.x) / 2
          const midY = (start.y + end.y) / 2
          drawBadge(midX, midY, `${wire.bitWidth}`, wireColor(wire))
        }
        wire.frameToggles = 0
      }

      function toggleProbe(wire) {
        if (!wire) return
        if (probes.has(wire.id)) {
          probes.delete(wire.id)
        } else {
          probes.set(wire.id, { history: [wire.value] })
        }
      }

      function drawProbes() {
        probes.forEach((probe, id) => {
          const wire = wires.find((w) => w.id === id)
          if (!wire) return
          const fromComp = components.find((c) => c.id === wire.fromCompId)
          const toComp = components.find((c) => c.id === wire.toCompId)
          if (!fromComp || !toComp) return
          const fromPort = fromComp.outputs.find((p) => p.id === wire.fromPortId)
          const toPort = toComp.inputs.find((p) => p.id === wire.toPortId)
          if (!fromPort || !toPort) return
          const start = portPosition(fromComp, fromPort)
          const end = portPosition(toComp, toPort)
          const midX = (start.x + end.x) / 2
          const midY = (start.y + end.y) / 2
          const lastVal = probe.history[probe.history.length - 1] ?? wire.value
          const boxW = 90
          const boxH = 34
          ctx.save()
          ctx.fillStyle = 'rgba(15,23,42,0.9)'
          ctx.strokeStyle = '#94a3b8'
          ctx.lineWidth = 1
          ctx.fillRect(midX - boxW / 2, midY - boxH / 2, boxW, boxH)
          ctx.strokeRect(midX - boxW / 2, midY - boxH / 2, boxW, boxH)
          ctx.fillStyle = '#e5e7eb'
          ctx.font = '10px "JetBrains Mono"'
          ctx.textAlign = 'center'
          ctx.textBaseline = 'middle'
          ctx.fillText(`0x${lastVal.toString(16)}`, midX, midY - 6)
          const hist = probe.history.slice(-20)
          if (hist.length) {
            ctx.strokeStyle = '#38bdf8'
            ctx.beginPath()
            hist.forEach((v, idx) => {
              const x = midX - boxW / 2 + 6 + (idx / Math.max(1, hist.length - 1)) * (boxW - 12)
              const y = midY + boxH / 2 - 8 - (Number(v !== 0n) * 10)
              if (idx === 0) ctx.moveTo(x, y)
              else ctx.lineTo(x, y)
            })
            ctx.stroke()
          }
          ctx.restore()
        })
      }

      function sampleProbes() {
        probes.forEach((probe, id) => {
          const wire = wires.find((w) => w.id === id)
          if (!wire) return
          const val = wire.value ?? 0n
          if (!logicAnalyzer.triggered) {
            if (logicAnalyzer.triggerWire === id && val !== 0n) {
              logicAnalyzer.triggered = true
            } else {
              return
            }
          }
          probe.history.push(val)
          if (probe.history.length > logicAnalyzer.maxSamples) {
            probe.history.shift()
          }
        })
      }

      function drawLogicAnalyzer() {
        laCanvas.style.display = logicAnalyzer.enabled ? 'block' : 'none'
        if (!logicAnalyzer.enabled) return
        const canvasWidth = laCanvas.clientWidth || window.innerWidth - HUD_OFFSET
        laCanvas.width = canvasWidth
        laCanvas.height = laCanvas.clientHeight || 140
        laCtx.fillStyle = '#0a0a0f'
        laCtx.fillRect(0, 0, laCanvas.width, laCanvas.height)
        const entries = Array.from(probes.entries())
        const rowHeight = 24
        const marginTop = 12
        entries.slice(0, Math.floor((laCanvas.height - marginTop) / rowHeight)).forEach(([id, probe], idx) => {
          const yMid = marginTop + idx * rowHeight + rowHeight / 2
          const data = probe.history
          if (!data.length) return
          laCtx.strokeStyle = logicAnalyzer.triggerWire === id ? '#22d3ee' : '#94a3b8'
          laCtx.beginPath()
          data.forEach((v, i) => {
            const x = (i / Math.max(1, logicAnalyzer.maxSamples - 1)) * laCanvas.width
            const high = v !== 0n
            const y = high ? yMid - 6 : yMid + 6
            if (i === 0) laCtx.moveTo(x, y)
            else laCtx.lineTo(x, y)
          })
          laCtx.stroke()
          laCtx.fillStyle = '#e5e7eb'
          laCtx.font = '10px "JetBrains Mono"'
          laCtx.textAlign = 'left'
          laCtx.fillText(id, 6, yMid + 10)
        })
      }

      function drawPort(comp, port) {
        const def = TOOLS[comp.type]
        const pos = portPosition(comp, port)
        const active = port.value !== 0n
        ctx.beginPath()
        ctx.fillStyle = '#0d0d0d'
        ctx.strokeStyle = def.color
        ctx.lineWidth = 2
        ctx.arc(pos.x, pos.y, PORT_RADIUS, 0, Math.PI * 2)
        ctx.fill()
        ctx.stroke()
        if (active) {
          ctx.fillStyle = '#fffa8b'
          ctx.beginPath()
          ctx.arc(pos.x, pos.y, PORT_RADIUS - 3, 0, Math.PI * 2)
          ctx.fill()
        }
        if (hoverPort && hoverPort.component === comp && hoverPort.port === port) {
          ctx.strokeStyle = '#fff'
          ctx.lineWidth = 1
          ctx.beginPath()
          ctx.arc(pos.x, pos.y, PORT_RADIUS + 2, 0, Math.PI * 2)
          ctx.stroke()
        }
        if (port.bitWidth > 1) {
          drawBadge(
            pos.x + (port.type === 'OUT' ? 16 : -16),
            pos.y,
            `${port.bitWidth}`,
            wireColor({ bitWidth: port.bitWidth })
          )
        }
      }

      function drawComponent(comp, isGhost = false) {
        const def = TOOLS[comp.type]
        const x = comp.gx * GRID_SIZE + camera.x
        const y = comp.gy * GRID_SIZE + camera.y
        const w = comp.w * GRID_SIZE
        const h = comp.h * GRID_SIZE

        ctx.save()
        if (isGhost) ctx.globalAlpha = 0.6
        ctx.fillStyle = selectedComponents.includes(comp) ? '#111827' : '#000'
        ctx.fillRect(x, y, w, h)
        ctx.strokeStyle = def.color
        ctx.lineWidth = 2
        ctx.strokeRect(x, y, w, h)

        ctx.fillStyle = def.color
        ctx.font = 'bold 12px "JetBrains Mono"'
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'

        if (comp.type === 'INPUT') {
          const pad = 8
          ctx.fillStyle = '#000'
          ctx.fillRect(x + pad, y + pad, w - pad * 2, h - pad * 2)
          const onText = comp.state ? 'ON' : 'OFF'
          ctx.fillStyle = comp.state ? '#4f4' : '#333'
          ctx.fillRect(
            x + pad + 2,
            y + pad + 2,
            w - pad * 2 - 4,
            h - pad * 2 - 4
          )
          ctx.fillStyle = '#fff'
          ctx.fillText(
            `${onText} x${comp.properties.bitWidth}`,
            x + w / 2,
            y + h / 2
          )
        } else if (comp.type === 'OUTPUT') {
          ctx.beginPath()
          ctx.arc(x + w / 2, y + h / 2, 12, 0, Math.PI * 2)
          ctx.fillStyle = '#000'
          ctx.fill()
          ctx.beginPath()
          ctx.arc(x + w / 2, y + h / 2, 8, 0, Math.PI * 2)
          if (comp.isLit) {
            ctx.fillStyle = '#ffff00'
            ctx.shadowColor = '#ffff00'
            ctx.shadowBlur = 20
          } else {
            ctx.fillStyle = '#333'
          }
          ctx.fill()
          ctx.shadowBlur = 0
          ctx.fillStyle = def.color
          ctx.fillText(`OUT x${comp.properties.bitWidth}`, x + w / 2, y + h - 12)
        } else {
          ctx.fillText(def.label, x + w / 2, y + h / 2)
          if (comp.properties.bitWidth) {
            ctx.fillStyle = '#888'
            ctx.font = '10px "JetBrains Mono"'
            ctx.fillText(`x${comp.properties.bitWidth}`, x + w / 2, y + h - 12)
          }
          if (comp.type === 'SPLITTER' || comp.type === 'MERGER') {
            ctx.fillStyle = '#888'
            ctx.font = '10px "JetBrains Mono"'
            ctx.fillText(`${comp.properties.busSize}-bit`, x + w / 2, y + 14)
          }
        }

        comp.inputs.forEach((p) => drawPort(comp, p))
        comp.outputs.forEach((p) => drawPort(comp, p))

        ctx.restore()
      }

      function drawAllComponents() {
        components.forEach((c) => drawComponent(c))
        if (placingType && TOOLS[placingType]) {
          drawComponent(
            new Component(mouseGrid.x, mouseGrid.y, placingType),
            true
          )
        } else if (placingType && customLibrary[placingType]) {
          const x = mouseGrid.x * GRID_SIZE + camera.x
          const y = mouseGrid.y * GRID_SIZE + camera.y
          const w = GRID_SIZE * 3
          const h = GRID_SIZE * 2
          ctx.save()
          ctx.globalAlpha = 0.6
          ctx.fillStyle = '#0f172a'
          ctx.strokeStyle = '#6ee7b7'
          ctx.lineWidth = 2
          ctx.fillRect(x, y, w, h)
          ctx.strokeRect(x, y, w, h)
          ctx.fillStyle = '#6ee7b7'
          ctx.font = 'bold 12px "JetBrains Mono"'
          ctx.textAlign = 'center'
          ctx.textBaseline = 'middle'
          ctx.fillText(placingType, x + w / 2, y + h / 2)
          ctx.restore()
        }
      }

      function render() {
        ctx.fillStyle = '#0f0f0f'
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        flowOffset = (flowOffset + 2) % 1000
        drawGrid()
        drawWires()
        drawAllComponents()
        drawLogicAnalyzer()
        if (selectionStart && selectionEnd) {
          const sx = Math.min(selectionStart.x, selectionEnd.x) * GRID_SIZE + camera.x
          const sy = Math.min(selectionStart.y, selectionEnd.y) * GRID_SIZE + camera.y
          const ex = (Math.max(selectionStart.x, selectionEnd.x) + 1) * GRID_SIZE + camera.x
          const ey = (Math.max(selectionStart.y, selectionEnd.y) + 1) * GRID_SIZE + camera.y
          ctx.strokeStyle = '#fff'
          ctx.lineWidth = 1
          ctx.setLineDash([5, 5])
          ctx.strokeRect(sx, sy, ex - sx, ey - sy)
          ctx.setLineDash([])
          ctx.fillStyle = 'rgba(255,255,255,0.08)'
          ctx.fillRect(sx, sy, ex - sx, ey - sy)
        }
        requestAnimationFrame(render)
      }

      function refreshHUD() {
        hud.innerHTML = ''

        const modalBtn = document.createElement('button')
        modalBtn.className = 'action'
        modalBtn.innerText = 'Save / Load'
        modalBtn.onclick = () => openModal('save')
        hud.appendChild(modalBtn)

        const verilogBtn = document.createElement('button')
        verilogBtn.className = 'action'
        verilogBtn.id = 'btn-export-verilog'
        verilogBtn.innerText = 'Export Verilog'
        verilogBtn.onclick = () => downloadVerilog()
        hud.appendChild(verilogBtn)

        const pauseBtn = document.createElement('button')
        pauseBtn.className = 'action'
        pauseBtn.innerText = isPaused ? 'Resume' : 'Pause'
        pauseBtn.onclick = togglePause
        hud.appendChild(pauseBtn)

        const stepBtn = document.createElement('button')
        stepBtn.className = isPaused ? 'action' : 'action disabled'
        stepBtn.innerText = 'Step (1 Tick)'
        stepBtn.disabled = !isPaused
        stepBtn.onclick = () => stepSimulation(1)
        hud.appendChild(stepBtn)

        const speedWrap = document.createElement('div')
        speedWrap.style.display = 'flex'
        speedWrap.style.flexDirection = 'column'
        speedWrap.style.gap = '4px'
        const speedLabel = document.createElement('span')
        speedLabel.style.fontSize = '11px'
        speedLabel.style.color = '#aaa'
        speedLabel.innerText = `Speed: ${ticksPerSecond} Hz`
        const speedInput = document.createElement('input')
        speedInput.type = 'range'
        speedInput.className = 'themed-input'
        speedInput.min = '1'
        speedInput.max = '240'
        speedInput.value = `${ticksPerSecond}`
        speedInput.oninput = (e) => setTickRate(Number(e.target.value))
        speedWrap.appendChild(speedLabel)
        speedWrap.appendChild(speedInput)
        hud.appendChild(speedWrap)

        const laBtn = document.createElement('button')
        laBtn.className = logicAnalyzer.enabled ? 'action active' : 'action'
        laBtn.innerText = 'Logic Analyzer'
        laBtn.onclick = () => {
          logicAnalyzer.enabled = !logicAnalyzer.enabled
          refreshHUD()
        }
        hud.appendChild(laBtn)

        const laSelect = document.createElement('select')
        laSelect.style.width = '100%'
        laSelect.className = 'themed-input'
        laSelect.id = 'logic-trigger-select'
        laSelect.onchange = (e) => {
          logicAnalyzer.triggerWire = e.target.value || null
          logicAnalyzer.triggered = logicAnalyzer.triggerWire ? false : true
        }
        const noneOpt = document.createElement('option')
        noneOpt.value = ''
        noneOpt.textContent = 'Trigger: none'
        laSelect.appendChild(noneOpt)
        probes.forEach((_, id) => {
          const opt = document.createElement('option')
          opt.value = id
          opt.textContent = `Trigger: ${id}`
          if (logicAnalyzer.triggerWire === id) opt.selected = true
          laSelect.appendChild(opt)
        })
        hud.appendChild(laSelect)

        const flowBtn = document.createElement('button')
        flowBtn.className = 'action'
        flowBtn.id = 'btn-flow-preview'
        flowBtn.innerText = 'Show Flow'
        flowBtn.onclick = (e) => showFlowPreview(e.currentTarget)
        hud.appendChild(flowBtn)

        const drcBtn = document.createElement('button')
        drcBtn.className = 'action'
        drcBtn.innerText = `Run DRC (${drcFindings.length})`
        drcBtn.onclick = () => {
          runDRC()
          refreshHUD()
        }
        hud.appendChild(drcBtn)
        if (drcFindings.length) {
          const drcList = document.createElement('div')
          drcList.style.fontSize = '11px'
          drcList.style.color = '#f97316'
          drcList.style.display = 'flex'
          drcList.style.flexDirection = 'column'
          drcList.style.gap = '4px'
          drcFindings.slice(0, MAX_DRC_DISPLAY_COUNT).forEach((f) => {
            const row = document.createElement('div')
            row.textContent = `âš  ${f.message}`
            drcList.appendChild(row)
          })
          hud.appendChild(drcList)
        }

        const selectBtn = document.createElement('button')
        selectBtn.className = mode === 'SELECTING' ? 'action active' : 'action'
        selectBtn.innerText = '[ ] Select Area'
        selectBtn.onclick = () => {
          mode = mode === 'SELECTING' ? 'IDLE' : 'SELECTING'
          selectionStart = null
          selectionEnd = null
          selectedComponents = []
          refreshHUD()
        }
        hud.appendChild(selectBtn)

        const saveCustomBtn = document.createElement('button')
        saveCustomBtn.className = 'action'
        saveCustomBtn.innerText = '+ Save Custom'
        saveCustomBtn.onclick = saveCustomComponent
        hud.appendChild(saveCustomBtn)

        const sep = document.createElement('div')
        sep.className = 'separator'
        hud.appendChild(sep)

        Object.keys(TOOLS).forEach((key) => {
          if (customLibrary[key]) return
          const def = TOOLS[key]
          const btn = document.createElement('button')
          const swatch = document.createElement('span')
          swatch.className = 'swatch'
          swatch.style.backgroundColor = def.color
          btn.appendChild(swatch)
          btn.appendChild(document.createTextNode(def.label))
          btn.onpointerdown = (e) => {
            e.preventDefault()
            placingType = key
            draggingFromMenu = true
            mouseGrid = getGrid({ x: e.clientX, y: e.clientY })
          }
          hud.appendChild(btn)
        })

        if (Object.keys(customLibrary).length) {
          const sepCustom = document.createElement('div')
          sepCustom.className = 'separator'
          hud.appendChild(sepCustom)
          Object.keys(customLibrary).forEach((key) => {
            const btn = document.createElement('button')
            const swatch = document.createElement('span')
            swatch.className = 'swatch'
            swatch.style.backgroundColor = '#6ee7b7'
            btn.appendChild(swatch)
            btn.appendChild(document.createTextNode(key))
            btn.onpointerdown = (e) => {
              e.preventDefault()
              placingType = key
              draggingFromMenu = true
              mouseGrid = getGrid({ x: e.clientX, y: e.clientY })
            }
            hud.appendChild(btn)
          })
        }

        const sep2 = document.createElement('div')
        sep2.className = 'separator'
        hud.appendChild(sep2)

        const clearBtn = document.createElement('button')
        clearBtn.className = 'danger'
        clearBtn.innerText = 'Clear All'
          clearBtn.onclick = () => {
            if (confirm('Reset Board?')) {
              clearAllState()
              refreshHUD()
            }
          }
          hud.appendChild(clearBtn)
      }

      function serializeProject() {
        return JSON.stringify(
          {
            format: 'OpenCircuit',
            version: '1.0',
            library: Object.values(customLibrary).map((def) => ({
              name: def.name,
              components: def.components,
              wires: def.wires,
              inputs: def.inputs,
              outputs: def.outputs,
              parameters: def.parameters || {},
            })),
            main: {
              components: components.map((c) => ({
                id: c.id,
                type: c.type,
                pos: { x: c.gx, y: c.gy },
                properties: c.properties,
                memory:
                  c.type === 'RAM' || c.type === 'ROM'
                    ? Array.from(ensureMemory(c) || [])
                    : undefined,
              })),
              wires: wires.map((w) => ({
                from: { comp: w.fromCompId, port: w.fromPortId },
                to: { comp: w.toCompId, port: w.toPortId },
                bitWidth: w.bitWidth,
                showFlow: !!w.showFlow,
                netName: w.netName || undefined,
                path: w.path || undefined,
                pathIsGrid: w.pathIsGrid || undefined,
              })),
            },
          },
          null,
          2
        )
      }

      function sanitizeId(name) {
        const s = String(name || 'n').replace(/[^a-zA-Z0-9_]/g, '_')
        return /^[0-9]/.test(s) ? `n_${s}` : s || 'n'
      }

      function widthDecl(width) {
        const bits = clampBits(width || 1)
        return bits > 1 ? `[${bits - 1}:0] ` : ''
      }

      function exportVerilog(moduleName = 'circuit') {
        const modName = sanitizeId(moduleName)
        const compById = new Map(components.map((c) => [c.id, c]))
        const wireToInput = new Map()
        wires.forEach((w) => {
          wireToInput.set(`${w.toCompId}:${w.toPortId}`, w)
        })

        const outputNet = new Map()
        function netNameForWire(wire, fallback) {
          if (wire?.netName) return sanitizeId(wire.netName)
          return fallback
        }
        function netForOutput(comp, port) {
          const key = `${comp.id}:${port.id}`
          if (outputNet.has(key)) return outputNet.get(key)
          let base =
            comp.type === 'INPUT'
              ? sanitizeId(comp.id)
              : sanitizeId(`${comp.id}_${port.id}`)
          const net = base || sanitizeId(key)
          outputNet.set(key, net)
          return net
        }

        function inputNet(comp, port) {
          const w = wireToInput.get(`${comp.id}:${port.id}`)
          if (!w) return DEFAULT_NET
          if (w.netName) return sanitizeId(w.netName)
          const src = compById.get(w.fromCompId)
          const srcPort = src?.outputs.find((p) => p.id === w.fromPortId)
          if (!src || !srcPort) return DEFAULT_NET
          return netForOutput(src, srcPort)
        }

        const inputs = components
          .filter((c) => c.type === 'INPUT')
          .map((c) => ({
            name: sanitizeId(c.id),
            width: c.properties.bitWidth || 1,
          }))

        const outputs = components
          .filter((c) => c.type === 'OUTPUT')
          .map((c) => ({
            name: sanitizeId(c.id),
            width: c.properties.bitWidth || 1,
            source: inputNet(c, c.inputs[0]),
          }))

        const wiresDecl = []
        const assigns = []

        components.forEach((comp) => {
          if (comp.type === 'INPUT' || comp.type === 'OUTPUT') return
          comp.outputs.forEach((port) => {
            const net = netNameForWire(
              wireToInput.get(`${comp.id}:${port.id}`),
              netForOutput(comp, port)
            )
            wiresDecl.push({ name: net, width: port.bitWidth })
          })
          const ins = comp.inputs.map((p) => inputNet(comp, p))
          switch (comp.type) {
            case 'NOT':
              assigns.push(
                `assign ${netForOutput(comp, comp.outputs[0])} = ~(${ins[0]});`
              )
              break
            case 'AND':
            case 'NAND': {
              const expr = ins.join(' & ')
              const base = `(${expr})`
              const body =
                comp.type === 'NAND'
                  ? `~${base}`
                  : base
              assigns.push(
                `assign ${netForOutput(comp, comp.outputs[0])} = ${body};`
              )
              break
            }
            case 'OR':
            case 'NOR': {
              const expr = ins.join(' | ')
              const base = `(${expr})`
              const body =
                comp.type === 'NOR'
                  ? `~${base}`
                  : base
              assigns.push(
                `assign ${netForOutput(comp, comp.outputs[0])} = ${body};`
              )
              break
            }
            case 'XOR':
            case 'XNOR': {
              const expr = ins.join(' ^ ')
              const base = `(${expr})`
              const body =
                comp.type === 'XNOR'
                  ? `~${base}`
                  : base
              assigns.push(
                `assign ${netForOutput(comp, comp.outputs[0])} = ${body};`
              )
              break
            }
            case 'SPLITTER': {
              const inNet = ins[0]
              comp.outputs.forEach((port, idx) => {
                assigns.push(
                  `assign ${netForOutput(comp, port)} = ${inNet}[${idx}];`
                )
              })
              break
            }
            case 'MERGER': {
              const concat = comp.inputs
                .map((_, idx) => ins[idx])
                .reverse()
                .join(', ')
              assigns.push(
                `assign ${netForOutput(comp, comp.outputs[0])} = {${concat}};`
              )
              break
            }
            default:
              break
          }
        })

        wires.forEach((w) => {
          if (w.netName) {
            wiresDecl.push({ name: sanitizeId(w.netName), width: w.bitWidth })
          }
        })

        outputs.forEach((out) => {
          if (out.source) {
            assigns.push(`assign ${out.name} = ${out.source};`)
          }
        })

        const uniqueWires = []
        const seenWire = new Set()
        wiresDecl.forEach((w) => {
          if (seenWire.has(w.name)) return
          seenWire.add(w.name)
          uniqueWires.push(w)
        })

        const lines = []
        const portList = [...inputs.map((p) => p.name), ...outputs.map((p) => p.name)]
        lines.push(`module ${modName}(${portList.join(', ')});`)
        inputs.forEach((p) =>
          lines.push(`  input ${widthDecl(p.width)}${p.name};`)
        )
        outputs.forEach((p) =>
          lines.push(`  output ${widthDecl(p.width)}${p.name};`)
        )
        uniqueWires.forEach((w) =>
          lines.push(`  wire ${widthDecl(w.width)}${w.name};`)
        )
        assigns.forEach((a) => lines.push(`  ${a}`))
        lines.push('endmodule')
        return lines.join('\n')
      }

      function downloadVerilog() {
        const name = prompt('Module name for export?', 'circuit') || 'circuit'
        const code = exportVerilog(name)
        if (navigator.clipboard?.writeText) {
          navigator.clipboard.writeText(code).catch((err) => {
            console.warn('Failed to copy Verilog code to clipboard', err)
          })
        } else {
          console.warn('Clipboard API unavailable; skipped copying Verilog')
        }
        const blob = new Blob([code], { type: 'text/plain' })
        const a = document.createElement('a')
        a.href = URL.createObjectURL(blob)
        a.download = `${sanitizeId(name)}.v`
        document.body.appendChild(a)
        a.click()
        a.remove()
        setTimeout(() => URL.revokeObjectURL(a.href), BLOB_CLEANUP_DELAY_MS)
      }

      function updateSaveTextarea() {
        saveTextarea.value = serializeProject()
      }

      async function handleLoad() {
        try {
          let text = loadTextarea.value.trim()
          if (loadFileInput.files && loadFileInput.files[0]) {
            text = await loadFileInput.files[0].text()
          }
          if (!text) {
            alert('Provide JSON via text area or file input.')
            return
          }
          const data = JSON.parse(text)
          loadProject(data)
          closeModal()
        } catch (err) {
          alert('Failed to load project: ' + err.message)
        }
      }

      function loadProject(data) {
        if (!data || data.format !== 'OpenCircuit') {
          throw new Error('Invalid format')
        }
        Object.keys(customLibrary).forEach((k) => {
          delete customLibrary[k]
          if (TOOLS[k]) delete TOOLS[k]
        })
        components = []
        wires = []
        probes.clear()
        drcFindings = []
        resetSimulationClock()
        const lib = data.library || []
        lib.forEach((d) => {
          if (!d.name) return
          registerCustomTool({
            name: d.name,
            components: d.components || [],
            wires: d.wires || [],
            inputs: d.inputs || [],
            outputs: d.outputs || [],
            parameters: d.parameters || {},
          })
        })
        const list = data.main?.components || []
        list.forEach((c) => {
          const props = { ...(c.properties || {}) }
          if (props.inputs && !props.busSize) props.busSize = props.inputs
          if (props.outputs && !props.busSize) props.busSize = props.outputs
          const comp = new Component(
            c.pos?.x ?? c.x ?? 0,
            c.pos?.y ?? c.y ?? 0,
            c.type,
            props
          )
          comp.id = c.id || comp.id
          if ((c.type === 'RAM' || c.type === 'ROM') && Array.isArray(c.memory)) {
            comp.memory = new Uint8Array(c.memory.map((v) => Number(v) & BYTE_MASK))
          }
          configureComponent(comp)
          components.push(comp)
        })

        const wireList = data.main?.wires || []
        wireList.forEach((w) => {
          const fromComp = components.find((c) => c.id === w.from?.comp)
          const toComp = components.find((c) => c.id === w.to?.comp)
          if (!fromComp || !toComp) return
          const fromPort = fromComp.outputs.find((p) => p.id === w.from?.port)
          const toPort = toComp.inputs.find((p) => p.id === w.to?.port)
          if (!fromPort || !toPort) return
          const bitWidth = w.bitWidth || fromPort.bitWidth
          if (fromPort.bitWidth !== toPort.bitWidth) return
          const wireObj = new Wire({
            id: w.id,
            fromCompId: fromComp.id,
            fromPortId: fromPort.id,
            toCompId: toComp.id,
            toPortId: toPort.id,
            bitWidth,
            showFlow: !!w.showFlow,
            netName: w.netName || null,
            path: w.path || null,
            pathIsGrid: !!w.pathIsGrid,
          })
          if (!wireObj.path) applyAutoRoute(wireObj)
          wires.push(wireObj)
        })
        seedInitialEvents()
        processEventsUntil(simTime)
      }

      function openModal(tab = 'save') {
        modalBackdrop.classList.remove('hidden')
        setModalTab(tab)
        updateSaveTextarea()
      }

      function clearAllState() {
        Object.keys(customLibrary).forEach((k) => {
          delete customLibrary[k]
          if (TOOLS[k]) delete TOOLS[k]
        })
        components = []
        wires = []
        probes.clear()
        selectedComponents = []
        resetSimulationClock()
        drcFindings = []
        seedInitialEvents()
      }

      function saveCustomComponent() {
        if (!selectedComponents.length) {
          alert('Select components first using Select Area.')
          return
        }
        const name = prompt('Custom component name:', `CHIP_${Object.keys(customLibrary).length + 1}`)
        if (!name) return

        const ids = new Set(selectedComponents.map((c) => c.id))
        let minX = Infinity
        let minY = Infinity
        selectedComponents.forEach((c) => {
          minX = Math.min(minX, c.gx)
          minY = Math.min(minY, c.gy)
        })

        const inputNodes = selectedComponents
          .filter((c) => c.type === 'INPUT')
          .sort((a, b) => a.gy - b.gy || a.gx - b.gx)
        const outputNodes = selectedComponents
          .filter((c) => c.type === 'OUTPUT')
          .sort((a, b) => a.gy - b.gy || a.gx - b.gx)

        const comps = selectedComponents.map((c) => ({
          id: c.id,
          type: c.type,
          gx: c.gx - minX,
          gy: c.gy - minY,
          properties: { ...c.properties },
        }))

        const wireList = wires
          .filter((w) => ids.has(w.fromCompId) && ids.has(w.toCompId))
          .map((w) => ({
            fromCompId: w.fromCompId,
            toCompId: w.toCompId,
            fromPortId: w.fromPortId,
            toPortId: w.toPortId,
            bitWidth: w.bitWidth,
          }))

        const def = {
          name,
          components: comps,
          wires: wireList,
          inputs: inputNodes.map((c) => ({
            componentId: c.id,
            bitWidth: c.properties.bitWidth || 1,
          })),
          outputs: outputNodes.map((c) => ({
            componentId: c.id,
            bitWidth: c.properties.bitWidth || 1,
          })),
        }
        registerCustomTool(def)
        refreshHUD()
      }

      function placeCustom(name, gx, gy) {
        const tmpl = customLibrary[name]
        if (!tmpl) return
        if (checkCollision(gx, gy, name)) return
        const comp = new Component(gx, gy, name)
        components.push(comp)
        queueComponent(comp, 0)
      }

      function placeFromPalette(gx, gy, type) {
        if (customLibrary[type]) {
          placeCustom(type, gx, gy)
          return
        }
        if (!checkCollision(gx, gy, type)) {
          const comp = new Component(gx, gy, type)
          components.push(comp)
          queueComponent(comp, 0)
        }
      }

      function hideContextMenu() {
        ctxMenu.classList.add('hidden')
        ctxMenu.innerHTML = ''
      }

      function showContextMenu(x, y, items) {
        ctxMenu.innerHTML = ''
        items.forEach((item) => {
          const btn = document.createElement('button')
          btn.innerText = item.label
          btn.onclick = () => {
            hideContextMenu()
            item.action()
          }
          ctxMenu.appendChild(btn)
        })
        ctxMenu.style.left = `${x}px`
        ctxMenu.style.top = `${y}px`
        ctxMenu.classList.remove('hidden')
      }

      function showFlowPreview(anchorEl) {
        if (!anchorEl) return
        hideContextMenu()
        const img = new Image()
        img.src = canvas.toDataURL('image/png')
        img.alt = 'Flow preview'
        img.style.maxWidth = '280px'
        img.style.borderRadius = '6px'
        img.style.display = 'block'
        const title = document.createElement('div')
        title.style.color = '#cbd5f5'
        title.style.fontSize = '12px'
        title.style.marginBottom = '6px'
        title.textContent = 'Current Flow Snapshot'
        ctxMenu.appendChild(title)
        ctxMenu.appendChild(img)
        const rect = anchorEl.getBoundingClientRect()
        ctxMenu.style.left = `${rect.right + 8}px`
        ctxMenu.style.top = `${rect.top}px`
        ctxMenu.classList.remove('hidden')
      }

      document.addEventListener('pointerdown', (e) => {
        if (!ctxMenu.classList.contains('hidden') && !ctxMenu.contains(e.target)) {
          hideContextMenu()
        }
      })

      function hitTestWire(clientX, clientY) {
        const tolerance = 8
        for (const w of wires) {
          const fromComp = components.find((c) => c.id === w.fromCompId)
          const toComp = components.find((c) => c.id === w.toCompId)
          if (!fromComp || !toComp) continue
          const a = portPosition(
            fromComp,
            fromComp.outputs.find((p) => p.id === w.fromPortId)
          )
          const b = portPosition(
            toComp,
            toComp.inputs.find((p) => p.id === w.toPortId)
          )
          if (!a || !b) continue
          const dx = b.x - a.x
          const dy = b.y - a.y
          const len2 = dx * dx + dy * dy
          if (len2 === 0) continue
          const t = Math.max(
            0,
            Math.min(1, ((clientX - a.x) * dx + (clientY - a.y) * dy) / len2)
          )
          const px = a.x + t * dx
          const py = a.y + t * dy
          const dist = Math.hypot(clientX - px, clientY - py)
          if (dist <= tolerance) return w
        }
        return null
      }

      function closeModal() {
        modalBackdrop.classList.add('hidden')
      }

      function setModalTab(tab) {
        const saveContent = document.querySelector(
          '.modal-content[data-tab="save"]'
        )
        const loadContent = document.querySelector(
          '.modal-content[data-tab="load"]'
        )
        if (tab === 'save') {
          tabSave.classList.add('active')
          tabLoad.classList.remove('active')
          saveContent.classList.remove('hidden')
          loadContent.classList.add('hidden')
          updateSaveTextarea()
        } else {
          tabLoad.classList.add('active')
          tabSave.classList.remove('active')
          saveContent.classList.add('hidden')
          loadContent.classList.remove('hidden')
        }
      }

      function initModalEvents() {
        modalClose.addEventListener('click', closeModal)
        tabSave.addEventListener('click', () => setModalTab('save'))
        tabLoad.addEventListener('click', () => setModalTab('load'))
        copyBtn.addEventListener('click', async () => {
          updateSaveTextarea()
          try {
            await navigator.clipboard.writeText(saveTextarea.value)
          } catch (err) {
            alert('Copy failed: ' + (err?.message || err))
          }
        })
        downloadBtn.addEventListener('click', () => {
          updateSaveTextarea()
          const blob = new Blob([saveTextarea.value], { type: 'application/json' })
          const url = URL.createObjectURL(blob)
          const a = document.createElement('a')
          a.href = url
          a.download = 'circuit.json'
          a.click()
          URL.revokeObjectURL(url)
        })
        applyLoadBtn.addEventListener('click', handleLoad)
      }

      function handleDoubleClick(e) {
        // double-tap editing disabled; use context menu instead
      }

      canvas.addEventListener('pointerdown', (e) => {
        const g = getGrid({ x: e.clientX, y: e.clientY })
        const portHit = hitTestPort(e.clientX, e.clientY)
        const wireHit = hitTestWire(e.clientX, e.clientY)
        hideContextMenu()

        if (mode === 'SELECTING') {
          selectionStart = g
          selectionEnd = g
          return
        }

        if (draggingFromMenu) return

        if (!portHit && wireHit) {
          toggleProbe(wireHit)
          return
        }

        if (portHit) {
          if (e.button === 2) {
            showContextMenu(e.clientX, e.clientY, [])
            return
          }
          draggingWireStart = portHit
          mode = 'CONNECTING'
          return
        }

        const compHit = componentAt(g.x, g.y)
        if (compHit) {
          if (compHit.type === 'INPUT' && e.button !== 2) {
            const posX = compHit.gx * GRID_SIZE + camera.x
            const posY = compHit.gy * GRID_SIZE + camera.y
            const relX = e.clientX - posX
            const relY = e.clientY - posY
            const pad = 8
            const w = compHit.w * GRID_SIZE
            const h = compHit.h * GRID_SIZE
            if (relX > pad && relX < w - pad && relY > pad && relY < h - pad) {
              compHit.state = !compHit.state
              queueComponent(compHit, 0)
              return
            }
          }
          mode = 'DRAGGING_EXISTING'
          draggingComp = compHit
          dragOffset = { x: g.x - compHit.gx, y: g.y - compHit.gy }
          draggingComp.initialPos = { gx: compHit.gx, gy: compHit.gy }
          return
        }

        if (placingType) {
          if (!checkCollision(g.x, g.y, placingType)) {
            components.push(new Component(g.x, g.y, placingType))
          }
          return
        }

        mode = 'PANNING'
        dragStart = { x: e.clientX - camera.x, y: e.clientY - camera.y }
      })

      window.addEventListener('pointermove', (e) => {
        mouseGrid = getGrid({ x: e.clientX, y: e.clientY })
        hoverPort = hitTestPort(e.clientX, e.clientY)
        if (mode === 'SELECTING' && selectionStart) {
          selectionEnd = mouseGrid
        }
        if (mode === 'PANNING') {
          camera.x = e.clientX - dragStart.x
          camera.y = e.clientY - dragStart.y
        } else if (mode === 'DRAGGING_EXISTING' && draggingComp) {
          draggingComp.gx = mouseGrid.x - dragOffset.x
          draggingComp.gy = mouseGrid.y - dragOffset.y
        }
      })

      window.addEventListener('pointerup', () => {
        if (draggingFromMenu && placingType) {
          placeFromPalette(mouseGrid.x, mouseGrid.y, placingType)
          draggingFromMenu = false
          placingType = null
        }

        if (mode === 'SELECTING' && selectionStart) {
          const sx = Math.min(selectionStart.x, selectionEnd?.x ?? selectionStart.x)
          const ex = Math.max(selectionStart.x, selectionEnd?.x ?? selectionStart.x)
          const sy = Math.min(selectionStart.y, selectionEnd?.y ?? selectionStart.y)
          const ey = Math.max(selectionStart.y, selectionEnd?.y ?? selectionStart.y)
          selectedComponents = components.filter((c) => {
            return (
              c.gx >= sx &&
              c.gx + c.w <= ex + 1 &&
              c.gy >= sy &&
              c.gy + c.h <= ey + 1
            )
          })
          selectionStart = null
          selectionEnd = null
          mode = 'IDLE'
        }

        if (mode === 'CONNECTING' && draggingWireStart) {
          const endPort = hoverPort
          if (endPort && endPort !== draggingWireStart) {
            tryConnectPorts(draggingWireStart, endPort)
          }
        }

        if (mode === 'DRAGGING_EXISTING' && draggingComp) {
          if (
            checkCollision(
              draggingComp.gx,
              draggingComp.gy,
              draggingComp.type,
              draggingComp.id
            )
          ) {
            draggingComp.gx = draggingComp.initialPos.gx
            draggingComp.gy = draggingComp.initialPos.gy
          }
          rerouteForComponent(draggingComp)
        }

        mode = 'IDLE'
        draggingComp = null
        draggingWireStart = null
      })

      window.addEventListener('contextmenu', (e) => {
        e.preventDefault()
        const g = getGrid({ x: e.clientX, y: e.clientY })
        const wireHit = hitTestWire(e.clientX, e.clientY)
        const compHit = componentAt(g.x, g.y)
        const items = []
        if (wireHit) {
          items.push({
            label: 'Delete wire',
            action: () => {
              probes.delete(wireHit.id)
              wires = wires.filter((w) => w !== wireHit)
              const dest = components.find((c) => c.id === wireHit.toCompId)
              if (dest) queueComponent(dest, gateDelay(dest.type))
            },
          })
          items.push({
            label: wireHit.showFlow ? 'Hide flow' : 'Show flow',
            action: () => {
              wireHit.showFlow = !wireHit.showFlow
            },
          })
          items.push({
            label: 'Set net name',
            action: () => {
              const next = prompt('Net name', wireHit.netName || '')
              if (next !== null) {
                wireHit.netName = next.trim() || null
              }
            },
          })
        }
        if (compHit) {
          if (compHit.type === 'SPLITTER' || compHit.type === 'MERGER') {
            items.push({
              label: 'Set bus size',
              action: () => {
                const next = prompt(
                  'Bus Width (1-64)',
                  compHit.properties.busSize ?? 8
                )
                if (next !== null) {
                  compHit.properties.busSize = clampBits(next, 8)
                  configureComponent(compHit)
                }
              },
            })
          }
          if (compHit.properties.bitWidth !== undefined) {
            items.push({
              label: 'Set bit width',
              action: () => {
                const next = prompt(
                  'Bit Width (1-64)',
                  compHit.properties.bitWidth ?? 1
                )
                if (next !== null) {
                  compHit.properties.bitWidth = clampBits(next, 1)
                  configureComponent(compHit)
                }
              },
            })
          }
          if (compHit.type === 'RAM' || compHit.type === 'ROM') {
            items.push({
              label: 'Hex Editor',
              action: () => openHexEditor(compHit),
            })
          }
          items.push({
            label: 'Delete component',
            action: () => removeComponent(compHit),
          })
        }
        if (!items.length) return
        showContextMenu(e.clientX, e.clientY, items)
      })

      canvas.addEventListener('dblclick', handleDoubleClick)
      window.addEventListener('contextmenu', (e) => e.preventDefault())
      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight
      })

      function apiLoad(json) {
        const data = typeof json === 'string' ? JSON.parse(json) : json
        loadProject(data)
        return true
      }

      window.CircuitAPI = {
        load: apiLoad,
        tick: (count = 1) => stepSimulation(count),
        readComponent: (id) => {
          const comp = components.find((c) => c.id === id)
          if (!comp) return null
          return {
            id: comp.id,
            type: comp.type,
            state: comp.state,
            isLit: comp.isLit,
            properties: { ...comp.properties },
            inputs: comp.inputs.map((p) => ({ id: p.id, value: p.value })),
            outputs: comp.outputs.map((p) => ({ id: p.id, value: p.value })),
          }
        },
        getWires: () =>
          wires.map((w) => ({
            id: w.id,
            from: { comp: w.fromCompId, port: w.fromPortId },
            to: { comp: w.toCompId, port: w.toPortId },
            bitWidth: w.bitWidth,
            value: w.value,
            showFlow: !!w.showFlow,
            netName: w.netName || null,
          })),
        toggleWireFlow: (id, enable) => {
          const wire = wires.find((w) => w.id === id)
          if (!wire) return false
          wire.showFlow = enable === undefined ? !wire.showFlow : Boolean(enable)
          return true
        },
        setNetName: (id, name) => {
          const wire = wires.find((w) => w.id === id)
          if (!wire) return false
          wire.netName = name ? String(name) : null
          return true
        },
        getNetName: (id) => wires.find((w) => w.id === id)?.netName || null,
        listNets: () => {
          const nets = new Map()
          wires.forEach((w) => {
            if (!w.netName) return
            if (!nets.has(w.netName)) nets.set(w.netName, [])
            nets.get(w.netName).push(w.id)
          })
          return Array.from(nets.entries()).map(([name, ids]) => ({ name, wires: ids }))
        },
        setSpeed: (hz) => setTickRate(hz),
        pause: () => pauseSimulation(),
        resume: () => resumeSimulation(),
        registerCustomTool: (def) => registerCustomTool(def),
        setInput: (id, value) => {
          const comp = components.find((c) => c.id === id && c.type === 'INPUT')
          if (!comp) return false
          comp.state = Boolean(value)
          if (value === null || value === undefined) {
            comp.overrideValue = null
          } else {
            comp.overrideValue = BigInt(value)
          }
          queueComponent(comp, 0)
          return true
        },
        exportVerilog: (moduleName) => exportVerilog(moduleName),
        reset: () => {
          clearAllState()
        },
        runDRC: () => runDRC(),
        autoRouteAll: () => {
          wires.forEach((w) => applyAutoRoute(w))
          return true
        },
        loadMemory: (id, data) => {
          const comp = components.find((c) => c.id === id)
          if (!comp) return false
          const mem = ensureMemory(comp)
          if (Array.isArray(data) || data instanceof Uint8Array) {
            mem.fill(0)
            mem.set(
              Array.from(data)
                .map((v) => Number(v) & BYTE_MASK)
                .slice(0, mem.length)
            )
            queueComponent(comp, 0)
            return true
          }
          return false
        },
        dumpMemory: (id) => {
          const comp = components.find((c) => c.id === id)
          if (!comp) return []
          return Array.from(ensureMemory(comp) || [])
        },
        openHexEditor: (id) => {
          const comp = components.find((c) => c.id === id)
          if (!comp) return false
          openHexEditor(comp)
          return true
        },
      }

      function init() {
        canvas.width = window.innerWidth
        canvas.height = window.innerHeight
        refreshHUD()
        initModalEvents()
        tickOnce()
        startTickLoop()
        render()
      }

      init()
    </script>
  </body>
</html>
